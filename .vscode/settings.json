{
    "files.exclude": {
        "**/__pycache__": true,
        "**/*.pyc": true,
        "_sass/_fonts.css": true,
        "_sass/_fonts.css.map": true,
        "_sass/_fonts.scss": true,
        "_sass/_jekyll-theme-minimal.css": true,
        "_sass/_jekyll-theme-minimal.css.map": true,
        "_sass/_minimal.css": true,
        "_sass/_minimal.css.map": true,
        "_sass/_minimal.scss": true,
        "_sass/_rouge-github.css": true,
        "_sass/_rouge-github.css.map": true,
        "_sass/_rouge-github.scss": true,
        "_site": true,
        ".github/workflows": true,
        ".idea": true,
        "404.html": true,
        "Gemfile": true,
        "Gemfile.lock": true,
        ".github": true,
        ".vscode": true,
        ".gitignore": true,
        "node_modules": true,
        "package-lock.json": true,
        "assets/css": true,
        "assets/fonts": true,
        "assets/img": true,
        "assets/js/scale.fix.js": true,
        "netlify.toml": true,
        ".ruby-version": true,
        "package.json": true,
        "netlify/functions": true,
        "netlify": true,
        "index.md": true,
        "about.md": true,
        "pytest.ini": true,
        ".venv": true,
        ".pytest_cache": true,
        "favicon.ico": true,
        "jest.config.js": true
    },
    "jest.shell": {
        "path": "/bin/bash",
        "args": ["--login"]
    },

/* Gemini Code Assist doesn't have a maximum text input  */


    "geminicodeassist.rules": "OAuth Quickstart: Add Login to Your JavaScript Application Auth0 allows you to add authentication to almost any application type quickly. This guide demonstrates how to integrate Auth0, add authentication, and display user profile information in a Single-Page Application (SPA) that uses plain JavaScript, using the Auth0 SPA SDK.  To use this quickstart, you’ll need to:  Sign up for a free Auth0 account or log in to Auth0.  Have a working project that you want to integrate with. Alternatively, you can view or download a sample application after logging in.  This quickstart assumes you are adding Auth0 to a plain JavaScript application, as opposed to using a framework such as React or Angular.  1 Configure Auth0 To use Auth0 services, you’ll need to have an application set up in the Auth0 Dashboard. The Auth0 application is where you will configure how you want authentication to work for the project you are developing.  Configure an application Use the interactive selector to create a new Auth0 application or select an existing application that represents the project you want to integrate with. Every application in Auth0 is assigned an alphanumeric, unique client ID that your application code will use to call Auth0 APIs through the SDK.  Any settings you configure using this quickstart will automatically update for your Application in the Dashboard, which is where you can manage your Applications in the future.  If you would rather explore a complete configuration, you can view a sample application instead.  Configure Callback URLs A callback URL is a URL in your application that you would like Auth0 to redirect users to after they have authenticated. If not set, users will not be returned to your application after they log in.  If you are following along with our sample project, set this to http://localhost:3000.  Configure Logout URLs A logout URL is a URL in your application that you would like Auth0 to redirect users to after they have logged out. If not set, users will not be able to log out from your application and will receive an error.  If you are following along with our sample project, set this to http://localhost:3000.  Configure Allowed Web Origins An Allowed Web Origin is a URL that you want to be allowed to access to your authentication flow. This must contain the URL of your project. If not properly set, your project will be unable to silently refresh authentication tokens, so your users will be logged out the next time they visit your application or refresh a page.  If you are following along with our sample project, set this to http://localhost:3000.  2 Add the Auth0 SPA SDK Auth0 provides a SPA SDK (auth0-spa-js) to simplify the process of implementing Auth0 authentication and authorization in JavaScript applications. You can install the Auth0 SPA SDK as an NPM package or from the CDN. For the purpose of this quickstart, we will use the CDN. Include this script tag on your HTML page:  <script src=\"https://cdn.auth0.com/js/auth0-spa-js/2.0/auth0-spa-js.production.js\"></script> Was this helpful?  / 3 Create the Auth0 client Create a new instance of the Auth0 client provided by the Auth0 SPA SDK and provide the Auth0 application details you created earlier in this quickstart.  If a user has previously logged in, the client will refresh the authentication state on page load; the user will still be logged in once the page is refreshed.  4 Add login to your application Now that you have configured your Auth0 Application, added the Auth0 SPA SDK, and created the Auth0 client, you need to set up login for your project. To do this, you will use the SDK’s loginWithRedirect() method to redirect users to the Auth0 Universal Login page where Auth0 can authenticate them. After a user successfully authenticates, they will be redirected to the callback URL you set up earlier in this quickstart.  Create a login button in your application that calls loginWithRedirect() when selected.  Checkpoint You should now be able to log in to your application.  Run your application, and select the login button. Verify that:  you can log in or sign up using a username and password  your application redirects you to the Auth0 Universal Login page  you are redirected to Auth0 for authentication  Auth0 successfully redirects back to your application after authentication  you do not receive any errors in the console related to Auth0  5 Handle the callback from Auth0 When the browser is redirected back to your application process, your application should call the handleRedirectCallback() function on the Auth0 client only when it detects a callback from Auth0. One way to do this is to only call handleRedirectCallback() when code and state query parameters are detected.  If handling the callback was successful, the parameters should be removed from the URL so the callback handler will not be triggered the next time the page loads.  Checkpoint Your callback from Auth0 should now be properly handled.  Run your application, and select the login button again. Verify that:  Auth0 successfully redirects back to your application after authentication.  the query parameters are removed from the URL.  6 Add logout to your application Users who log in to your project will also need a way to log out. The Auth0 client provides a logout() method that you can use to log a user out of your app. When users log out, they will be redirected to your Auth0 logout endpoint, which will then immediately redirect them to your application and the logout URL you set up earlier in this quickstart.  Create a logout button in your application that calls logout() when selected.  The SDK exposes an isAuthenticated() function that allows you to check whether a user is authenticated or not. You can render the login and logout buttons conditionally based on the value of the isAuthenticated() function. Alternatively, you can use a single button to combine both login and logout buttons as well as their conditional rendering.  Checkpoint  You should now be able to log out of your application.  Run your application, log in, and select the logout button. Verify that:  you are redirected to Auth0's logout endpoint.  Auth0 successfully redirects back to your application and the correct logout URL.  you are no longer logged in to your application.  you do not receive any errors in the console related to Auth0.  7 Show user profile information Now that your users can log in and log out, you will likely want to be able to retrieve the profile information associated with authenticated users. For example, you may want to be able to personalize the user interface by displaying a logged-in user’s name or profile picture.  The Auth0 SPA SDK provides user information through the getUser() function exposed by the Auth0 client. The Auth0 client also exposes an isAuthenticated() function that allows you to check whether a user is authenticated or not, which you can use to determine whether to show or hide UI elements, for example. Review the code in the interactive panel to see examples of how to use these functions.  Checkpoint You should now be able to view user profile information.  Run your application, and verify that:  user information displays correctly after you have logged in.  user information does not display after you have logged out.\n\n\n\nSample OAuth Application README: # Sample 01 - Login  The purpose of this article is to demonstrate how simple it is to set up and use the new Single Page Application SDK, and authenticate a user in your application using Auth0's Universal Login Page.  ## Running the Sample Application  The sample can be run locally, by cloning the repository to your machine and then following the steps below.  ### Specifying Auth0 Credentials  To specify the application client ID and domain, make a copy of `auth_config.json.example` and rename it to `auth_config.json`. Then open it in a text editor and supply the values for your application:  ```json {   \"domain\": \"{DOMAIN}\",   \"clientId\": \"{CLIENT_ID}\" } ```  ### Installation  After cloning the repository, run:  ```bash $ npm install ```  This will install all of the necessary packages in order for the sample to run.  ### Running the Application  This version of the application uses an [Express](https://expressjs.com) server that can serve the site from a single page. To start the app from the terminal, run:  ```bash $ npm run dev ```  ## Frequently Asked Questions  We are compiling a list of questions and answers regarding the new JavaScript SDK - if you're having issues running the sample applications, [check the FAQ](https://github.com/auth0/auth0-spa-js/blob/master/FAQ.md)!  ## What is Auth0?  Auth0 helps you to:  - Add authentication with [multiple authentication sources](https://docs.auth0.com/identityproviders), either social like **Google, Facebook, Microsoft Account, LinkedIn, GitHub, Twitter, Box, Salesforce, among others**, or enterprise identity systems like **Windows Azure AD, Google Apps, Active Directory, ADFS or any SAML Identity Provider**. - Add authentication through more traditional **[username/password databases](https://docs.auth0.com/mysql-connection-tutorial)**. - Add support for **[linking different user accounts](https://docs.auth0.com/link-accounts)** with the same user. - Support for generating signed [Json Web Tokens](https://docs.auth0.com/jwt) to call your APIs and **flow the user identity** securely. - Analytics of how, when and where users are logging in. - Pull data from other sources and add it to the user profile, through [JavaScript rules](https://docs.auth0.com/rules).  ## Create a free Auth0 account  1. Go to [Auth0](https://auth0.com/signup) and click Sign Up. 2. Use Google, GitHub or Microsoft Account to login.  ## Issue Reporting  If you have found a bug or if you have a feature request, please report them at this repository issues section. Please do not report security vulnerabilities on the public GitHub issue tracker. The [Responsible Disclosure Program](https://auth0.com/whitehat) details the procedure for disclosing security issues.  ## Author  [Auth0](auth0.com)  ## License  This project is licensed under the MIT license. See the [LICENSE](LICENSE.txt) file for more info.\n\n\n\nNetlify API Documentation: Get started with the Netlify API Use the Netlify REST API to manage atomic deploys of your sites and apps, manage form submissions, inject JavaScript snippets, manage DNS, and so much more.   This document covers the basics for interacting with the Netlify API, plus instructions for deploying sites and notes on some commonly used endpoints.  You can browse the OpenAPI reference for the Netlify API to explore available endpoints. Visit our Forums for more tips and conversation about understanding and using Netlify’s API.  Additionally, we have two API clients for your convenience:  Go Client JS Client If you’d like to interact with the Netlify API using a no-code tool, you can use n8n.io’s Netlify node. The node currently supports the following operations:  Create a new deployment Get a deployment Get all deployments Cancel a deployment Get a site Get all sites Delete a site #Make a request All URLs start with https://api.netlify.com/api/v1/. SSL only. The path is prefixed with the API version. If we change the API in backward-incompatible ways, we’ll bump the version marker and maintain stable support for the old URLs.  To make a request for all sites you have access to, for example, append the sites index path to the base URL to form something like https://api.netlify.com/api/v1/sites. Here’s an example in curl:  curl -H \"User-Agent: MyApp (YOUR_NAME@EXAMPLE.COM)\" \\      -H \"Authorization: Bearer YOUR_OAUTH2_ACCESS_TOKEN\" \\      https://api.netlify.com/api/v1/sites  #Authentication Netlify uses OAuth2 for authentication. All requests must use HTTPS.  To generate a personal access token (PAT):  Go to Applications > Personal access tokens. Select New access token. Enter a descriptive name to help you remember what the token will be used for. Select Allow access to my SAML-based Netlify team to authorize access to your SAML-based team data through the API. Select an Expiration date for your token to help keep your information secure. Select Generate token. Copy the token to your clipboard and store it in a safe location. Once you navigate away from this page, you won’t be able to access the value again. Select Done. Use your PAT for manual authentication in shell scripts or commands that use the Netlify API.  To authenticate API requests, include the token in the authorization header:  Authorization: Bearer <YOUR_PERSONAL_ACCESS_TOKEN>  To authenticate in shell scripts, refer to the code sample above for an example of how to use this token in a curl request.  SAML SSO  If your team requires you to log in with single sign-on (SSO), your personal access tokens will be denied access to the team by default. You can choose to grant access to the team when you generate a new token. You must be logged in to the team with SSO to grant access to it.  If you’re making a public integration with Netlify for others to enjoy, you must use OAuth2. This allows users to authorize your application to use Netlify on their behalf without having to copy/paste API tokens or touch sensitive login info. You’ll need an application client key and a client secret to integrate with the Netlify API. You can register a new application in your Netlify user settings for OAuth applications. Visit our blog post on integrating with Netlify for more information including common grant types and an example project.  The OAuth2 end-user authorization endpoint is https://app.netlify.com/authorize.  #Rate limiting To protect Netlify from getting flooded by automated deploys or misbehaving applications, the Netlify API is rate limited.  You can make up to 500 requests per minute for most requests. Certain operations have their own stricter limits. For example, you can deploy through the Netlify API up to 3 times per minute and up to 100 times per day.  You can check the returned HTTP headers of any API request to verify your current rate limit status:  X-RateLimit-Limit: 500 X-RateLimit-Remaining: 56 X-RateLimit-Reset: 1372700873  If you need higher limits, please contact us.  #Pagination All API requests that return over 100 items are paginated by default, with a limit of 100 items per page. You can specify further pages with the ?page parameter. You can also set a custom page size that’s less than 100 with the ?per_page parameter.  Note that page numbering starts with 1 and that omitting the ?page parameter will return the first page.  #Link header The pagination info is included in the Link header.  Link: <https://api.netlify.com/api/v1/sites?page=3&per_page=20>; rel=\"next\",     <https://api.netlify.com/api/v1/sites?page=5&per_page=20>; rel=\"last\"  Linebreak is included for readability.  The possible rel values are:  next Shows the URL of the immediate next page of results. last Shows the URL of the last page of results. prev Shows the URL of the immediate previous page of results. #Deploy with the API The most common API action is doing deploys, either of a new site or an existing site. If builds are stopped for an existing site, you can still deploy with the API to update the site.  Netlify supports two ways of doing deploys:  Sending a digest of all files in your deploy, and then uploading any files Netlify doesn’t already have on its storage servers. Sending a ZIP file of the entire site and letting Netlify unzip and deploy. We generally recommend the first way, since it’s more efficient.  Whether you deploy a brand new site or create a deploy within an existing site, the process is similar.  First create a new site, if needed:  POST /api/v1/sites  Now you have a site ID and you can create a new deploy, either with a file digest or a ZIP file.  #File digest method We recommend using a digest including a file path and SHA1 for each item. This method also allows you to upload serverless functions, however serverless functions should use SHA256 instead.  POST /api/v1/sites/{site_id}/deploys  {   \"files\": {     \"/index.html\": \"907d14fb3af2b0d4f18c2d46abe8aedce17367bd\",     \"/main.css\": \"f18c2d7367bd9046abe8aedce17d14fb3af2b0d4\"   },   \"functions\": {     \"hello-world\": \"708b029d8aa9c8fa513d1a25b97ffb6efb12b423\"   } }  When using a file digest, the API will return an object which includes the following properties:  {   \"id\": \"1234\",   \"required\": [\"907d14fb3af2b0d4f18c2d46abe8aedce17367bd\"],   \"required_functions\": [\"708b029d8aa9c8fa513d1a25b97ffb6efb12b423\"] }  The required property will give you a list of files by SHA1 that you need to upload. Similarly, required_functions will get you an array of required functions by SHA256 to upload, if you included a functions digest when creating the deploy.  Tip  If you have two files with the same SHA1, you don’t have to upload both of them.  Now upload the files, using the deploy ID returned as id in the file digest response:  PUT /api/v1/deploys/{deploy_id}/files/index.html  Warning  Be sure to escape the file_path parameter, and ensure file paths don’t include # or ? characters.  Use Content-Type: application/octet-stream and use the file contents as the HTTP request body.  If the required file is a function, upload it to the functions endpoint, again using the deploy ID returned as id in the file digest response:  PUT /api/v1/deploys/{deploy_id}/functions/hello-world?runtime=js  Possible runtime parameters are:  js: zipped Node.js programs or bundled JavaScript files go: Go binaries When uploading functions, use the name of the function, not the file path or any file extensions. Clients must zip the function prior to uploading to the API.  Once all files have been uploaded, Netlify will post process the deploy and invalidate the CDN.  #Async requests for large deploys API requests that last longer than 30 seconds will be terminated automatically. When creating large deploys, pass the async property in your file digest:  {   \"async\": true,   \"files\": {     \"/index.html\": \"907d14fb3af2b0d4f18c2d46abe8aedce17367bd\"   },   \"functions\": {     \"hello-world\": \"708b029d8aa9c8fa513d1a25b97ffb6efb12b423\"   } }  The request will then return the deploy ID (as id) which can be polled to determine when the deploy is ready for file uploads.  GET /api/v1/sites/{site_id}/deploys/{deploy_id}  You can check the state parameter in the response. It will be set to preparing as the upload manifest is generated, and either prepared, uploading, uploaded, or ready depending on the contents of the deploy. At this point, the deploy is either ready, or the API will give you a list of required files and required_functions.  Additionally, when uploading large files, sometimes the request will time out. It is safe to retry these uploads a few times to verify whether additional attempts are successful.  #ZIP file method You can deploy using a ZIP file but note there’s a limit of 25,000 files per zip extraction for a site. For the same site, you always need to upload a single zip with all the files.  To deploy using a ZIP file, create a new deploy with Content-Type: application/zip and the ZIP file as the HTTP request body:  POST /api/v1/sites/{site_id}/deploys  A deploy from a ZIP file will enter post-processing mode straight after being created.  While we generally recommend using file digests, you can use the ZIP file method straight from the command line with cURL:  curl -H \"Content-Type: application/zip\" \\      -H \"Authorization: Bearer YOUR_OAUTH2_ACCESS_TOKEN\" \\      --data-binary \"@website.zip\" \\      https://api.netlify.com/api/v1/sites/mysite.netlify.app/deploys  #Create and deploy at once When creating a new site, you can include a file digest or a ZIP file straight away, to save an HTTP request.  The following will create a new site and deploy it from a ZIP file:  curl -H \"Content-Type: application/zip\" \\      -H \"Authorization: Bearer YOUR_OAUTH2_ACCESS_TOKEN\" \\      --data-binary \"@website.zip\" \\      https://api.netlify.com/api/v1/sites  #Poll for deploy state You can poll the deploy to check the state:  GET /api/v1/deploys/{deploy_id}  { \"id\": \"1234\", \"state\": \"ready\" }  Once the state changes to ready, the deploy is live.  #Draft deploys When creating a new deploy, you can set \"draft\": true to mark the deploy as a draft deploy.  A draft deploy works like a normal deploy, but it won’t change the current published deploy of the site when it’s done processing.  #Commonly used endpoints This section describes usage for some popular endpoints.  We also have an OpenAPI reference for the Netlify API that you can explore.  Visit our Forums for more tips and conversation about understanding and using Netlify’s API.  #Sites The /sites endpoint allows you to access sites deployed on Netlify.  Trying to manage your site’s environment variables?  To update or retrieve your site’s environment variables, leverage the environment variables endpoints. The /sites endpoint does not support environment variables.  #Get sites GET /api/v1/sites returns all sites you have access to.  [   {     \"id\": \"3970e0fe-8564-4903-9a55-c5f8de49fb8b\",     \"premium\": false,     \"claimed\": true,     \"name\": \"synergy\",     \"custom_domain\": \"www.example.com\",     \"url\": \"http://www.example.com\",     \"admin_url\": \"https://api.netlify.com/sites/synergy\",     \"screenshot_url\": null,     \"created_at\": \"2013-09-17T05:13:08Z\",     \"updated_at\": \"2013-09-17T05:13:19Z\",     \"user_id\": \"51f60d2d5803545326000005\"   } ]  #Get site GET /api/v1/sites/{site_id} returns the specified site.  About site IDs  You can find a value for {site_id} by visiting the Netlify UI at Project configuration > General > Project details > Project information. Project IDs (formerly called site IDs) are also available in the response when you create a site or get a list of sites. Whenever the API requires a {site_id}, you can either use the id of a site obtained through the API, or the domain of the site (for example, mysite.netlify.app or www.example.com). These two are interchangeable whenever they’re used in API paths. GET /api/v1/sites/3970e0fe-8564-4903-9a55-c5f8de49fb8b returns the site with a matching id.  GET /api/v1/sites/www.example.com returns the site matching the domain www.example.com.  {   \"id\": \"3970e0fe-8564-4903-9a55-c5f8de49fb8b\",   \"premium\": false,   \"claimed\": true,   \"name\": \"synergy\",   \"custom_domain\": \"www.example.com\",   \"notification_email\": \"me@example.com\",   \"url\": \"http://www.example.com\",   \"admin_url\": \"https://api.netlify.com/sites/synergy\",   \"screenshot_url\": null,   \"created_at\": \"2013-09-17T05:13:08Z\",   \"updated_at\": \"2013-09-17T05:13:19Z\",   \"user_id\": \"51f60d2d5803545326000005\" }  #Create site POST /api/v1/sites creates a new site. By default the site will be created in your personal team.  When creating a site, you can set the following properties:  name: the name of the site (mysite.netlify.app) custom_domain: the custom domain of the site (www.example.com) password: password protect the site force_ssl: will force SSL on the site if SSL is enabled processing_settings: sets the Pretty URLs post processing setting: {   \"html\": { \"pretty_urls\": true } }  repo: configures continuous deployment. It’s a bit complicated to create a repo object so please visit our Forums for a verified Support Guide on linking a repository using the API. #Create site in team POST /api/v1/{account_slug}/sites/ creates a new site in a specific team. It takes the same parameters as when creating a site.  #Update site PATCH /api/v1/sites/{site_id} updates some attributes on a site.  PUT /api/v1/sites/{site_id} updates some attributes on a site.  This lets you update a site. It takes all the same parameters as when creating a site.  If you do a PUT request to a site with Content-Type: application/zip and a zipped website in the HTTP request body, it works exactly like creating a new deploy for the site based on a ZIP file.  #Provision SSL for a site POST /api/v1/sites/{site_id}/ssl activates SSL for a site.  The site must have a custom domain with DNS records configured to point to Netlify’s infrastructure.  Any domain aliases with valid DNS records will also be included in the SSL certificate for the site.  This endpoint manually triggers SSL provisioning for a site’s custom domains. Once SSL provisioning is successful, the domain will be served over HTTPS.  #Delete site DELETE /api/v1/sites/{site_id} permanently deletes a site.  This will return 200 OK.  #Site metadata Each site has a metadata object. The properties of the metadata object can be used within the snippets for a site by using the Liquid template syntax.  #Get metadata GET /api/v1/sites/{site_id}/metadata gets the metadata for a site.  {   \"my_meta_key\": \"my_meta_value\" }  #Update metadata PUT /api/v1/sites/{site_id}/metadata replaces the metadata object with a new metadata object.  #Environment variables The environment variables API endpoints allow you to access and set both site and shared environment variables. Environment variable changes require a build and deploy to take effect.  #Get environment variables GET /api/v1/accounts/{account_id}/env returns all environment variables for a team or site. The list will only include shared environment variables if the request is made by a Team Owner.  GET /api/v1/accounts/{account_id}/env/{key} returns an individual environment variable for a team or site.  About account IDs  You can find a value for {account_id} by querying GET /api/v1/accounts/{account_slug}. The slug is available in the Netlify UI at Team settings > General > Team details > Team information. An account in the Netlify REST API is equivalent to a team in the UI. Whenever the API requires an {account_id}, you can substitute {account_slug}. These two are interchangeable whenever they’re used in API paths. #Create and update environment variables POST /api/v1/accounts/{account_id}/env creates site or shared environment variables with the specified scopes and contextual values. An environment variable’s contextual values are the different values set for use in each deploy context.  PUT /api/v1/accounts/{account_id}/env/{key} updates an existing environment variable by replacing all of its values with the values provided with this request.  PATCH /api/v1/accounts/{account_id}/env/{key} updates or creates a new value for an existing environment variable.  #Delete environment variables DELETE /api/v1/accounts/{account_id}/env/{key} deletes an environment variable and all of its values.  DELETE /api/v1/accounts/{account_id}/env/{key}/value/{id} deletes a specific environment variable value.  #Files All files deployed by Netlify can be read through the API. Where the public URL of a file will serve the processed version for HTML pages, the files accessed through the API are the original uploaded files.  Netlify is based on a concept of atomic deploys. This means you never work on individual files. If you want to change a file, you do a new deploy with a new version of the site. To delete a file, you create a new deploy without the file. The file digest based deployment method means that these operations are fast and low-cost. Atomic deploys guarantees that your site is never in an inconsistent state where some files are being uploaded and where users might get HTML files that are not in sync with the CSS, image files, etc.  #Get files GET /api/v1/sites/{site_id}/files returns a list of all the files in the current deploy.  [   {     \"id\": \"/index.html\",     \"path\": \"/index.html\",     \"sha\": \"20828dcdf2cd07e5980fe52759101591bf5014ab\",     \"mime_type\": \"text/html\",     \"size\": 27232   } ]  #Get file GET /api/v1/sites/{site_id}/files/{file_path} returns the file.  {   \"id\": \"/index.html\",   \"path\": \"/index.html\",   \"sha\": \"20828dcdf2cd07e5980fe52759101591bf5014ab\",   \"mime_type\": \"text/html\",   \"size\": 27232 }  You can get the raw contents of the file by using the custom media type application/vnd.bitballoon.v1.raw as the Content-Type of your HTTP request.  #Deploys You can access all deploys for a specific site.  #Get deploys GET /api/v1/sites/{site_id}/deploys returns a list of all deploys for a site.  [   {     \"id\": \"52465f435803544542000001\",     \"premium\": false,     \"claimed\": true,     \"name\": \"synergy\",     \"custom_domain\": \"www.example.com\",     \"notification_email\": \"me@example.com\",     \"url\": \"http://www.example.com\",     \"deploy_url\": \"http://52465f435803544542000001.some-site.netlify.app\",     \"admin_url\": \"https://api.netlify.com/sites/synergy\",     \"screenshot_url\": null,     \"created_at\": \"2013-09-17T05:13:08Z\",     \"updated_at\": \"2013-09-17T05:13:19Z\",     \"user_id\": \"51f60d2d5803545326000005\",     \"state\": \"old\"   } ]  #Get deploy GET /api/v1/sites/{site_id}/deploys/{deploy_id} returns a specific deploy.  {   \"id\": \"52465f435803544542000001\",   \"premium\": false,   \"claimed\": true,   \"name\": \"synergy\",   \"custom_domain\": \"www.example.com\",   \"notification_email\": \"me@example.com\",   \"url\": \"http://www.example.com\",   \"deploy_url\": \"http://52465f435803544542000001.some-site.netlify.app\",   \"admin_url\": \"https://api.netlify.com/sites/synergy\",   \"screenshot_url\": null,   \"created_at\": \"2013-09-17T05:13:08Z\",   \"updated_at\": \"2013-09-17T05:13:19Z\",   \"user_id\": \"51f60d2d5803545326000005\",   \"state\": \"old\" }  #Restore deploy (rollback) POST /api/v1/sites/{site_id}/deploys/{deploy_id}/restore restores an old deploy and makes it the live version of the site.  {   \"id\": \"52465f435803544542000001\",   \"premium\": false,   \"claimed\": true,   \"name\": \"synergy\",   \"custom_domain\": \"www.example.com\",   \"notification_email\": \"me@example.com\",   \"url\": \"http://www.example.com\",   \"deploy_url\": \"http://52465f435803544542000001.some-site.netlify.app\",   \"admin_url\": \"https://api.netlify.com/sites/synergy\",   \"screenshot_url\": null,   \"created_at\": \"2013-09-17T05:13:08Z\",   \"updated_at\": \"2013-09-17T05:13:19Z\",   \"user_id\": \"51f60d2d5803545326000005\",   \"state\": \"current\" }  #Snippets Snippets are code snippets that are injected into every HTML page of the website, either right before the closing head tag or right before the closing body tag.  Each snippet can specify code for all pages and code that gets injected into “Thank you” pages shown after a successful form submission.  #Get snippets GET /api/v1/sites/{site_id}/snippets gets a list of snippets specific to a site.  [   {     \"id\": 0,     \"title\": \"Test\",     \"general\": \"\\u003Cscript\\u003Ealert(\\\"Hello\\\")\\u003C/script\\u003E\",     \"general_position\": \"head\",     \"goal\": \"\",     \"goal_position\": \"footer\"   } ]  The general property is the code that will be injected right before either the head or body end tag. The general_position can be head or footer and determines whether to inject the code in the head element or before the closing body tag.  The goal property is the code that will be injected into the “Thank you” page after a form submission. goal_position determines where to inject this code.  #Get snippet GET /api/v1/sites/{site_id}/snippets/{snippet_id} gets a specific snippet.  {   \"id\": 0,   \"title\": \"Test\",   \"general\": \"\\u003Cscript\\u003Ealert(\\\"Hello\\\")\\u003C/script\\u003E\",   \"general_position\": \"head\",   \"goal\": \"\",   \"goal_position\": \"footer\" }  #Add snippet POST /api/v1/sites/{site_id}/snippets adds a new snippet to a site.  #Update snippet PUT /api/v1/sites/{site_id}/snippets/{snippet_id} replaces a snippet.  #Delete snippet DELETE /api/v1/sites/{site_id}/snippets/{snippet_id} deletes a snippet.  #Forms You can access all Netlify Forms metadata and submissions for a site.  #Get forms GET /api/v1/sites/{site_id}/forms returns a list of all forms for a site, including metadata about each form, but not including form submissions.  [   {     \"id\": \"ac0865cc46440b1e64666f520e8d88d670c8a2f6\",     \"site_id\": \"0d3a9d2f-ef94-4380-93df-27ee400e2048\",     \"name\": \"Landing Page\",     \"paths\": [\"/index\"],     \"submission_count\": 3,     \"fields\": [       { \"name\": \"name\", \"type\": \"text\" },       { \"name\": \"email\", \"type\": \"email\" },       { \"name\": \"phone\", \"type\": \"text\" },       { \"name\": \"company\", \"type\": \"text\" },       { \"name\": \"website\", \"type\": \"url\" },       { \"name\": \"number_of_employees\", \"type\": \"select\" }     ],     \"created_at\": \"2013-09-18T20:26:19Z\"   } ]  #Get verified submissions GET /api/v1/sites/{site_id}/submissions returns a list of verified form submissions across all forms for a specific site.  GET /api/v1/forms/{form_id}/submissions returns a list of verified form submissions for a specific form.  [   {     \"id\": \"5231110b5803540aeb000019\",     \"number\": 13,     \"title\": null,     \"email\": \"test@example.com\",     \"name\": \"Mathias Biilmann\",     \"first_name\": \"Mathias\",     \"last_name\": \"Biilmann\",     \"company\": \"Netlify\",     \"summary\": \"Hello, World\",     \"body\": \"Hello, World\",     \"data\": {       \"email\": \"test@example.com\",       \"name\": \"Mathias Biilmann\",       \"ip\": \"127.0.0.1\"     },     \"created_at\": \"2013-09-12T00:55:39Z\",     \"site_url\": \"http://synergy.netlify.app\"   } ]  #Get spam submissions To get spam submissions, add a state=spam query parameter to the URL:  GET /api/v1/sites/{site_id}/submissions?state=spam returns a list of spam form submissions across all forms for a specific site.  GET /api/v1/forms/{form_id}/submissions?state=spam returns a list of spam form submissions for a specific form.  #Change submission state You can change the state of a submission from spam to verified or vice versa.  PUT /api/v1/submissions/{submission_id}/spam marks the submission as spam.  PUT /api/v1/submissions/{submission_id}/ham marks the submission as verified.  #Delete submissions DELETE /api/v1/submissions/{submission_id} removes a form submission.  #Delete form DELETE /api/v1/sites/{site_id}/forms/{form_id} removes a form and any existing submissions to it.  Future submissions to the form will result in a 404 error, and previous submissions will no longer be available.  #Hooks Netlify can trigger webhooks, send email notifications, or send Slack messages on certain events.  The /hooks endpoint lets you control the hooks for your site.  #Get hook types GET /api/v1/hooks/types returns a list of types of hooks that you can configure on Netlify.  [   {     \"name\": \"url\",     \"fields\": [       {         \"name\": \"url\",         \"options\": {           \"type\": \"string\",           \"title\": \"URL to notify\"         }       }     ],     \"events\": [\"submission_created\", \"deploy_created\", \"deploy_failed\"]   } ]  Each type has a series of fields that you need to set to create a new hook, and a list of events that can trigger them.  #Get hooks for a site GET /api/v1/hooks?site_id={site_id} returns a list of a hooks defined for a specific site.  [   {     \"id\": \"5636b7a00d61eec2d6001004\",     \"site_id\": \"0d3a9d2f-ef94-4380-93df-27ee400e2048\",     \"type\": \"email\",     \"event\": \"submission_created\",     \"data\": { \"email\": \"test@example.com\" },     \"created_at\": \"2015-10-20T21:51:51Z\",     \"updated_at\": \"2015-10-20T21:51:51Z\"   } ]  #Create hook POST /api/v1/hooks creates a new hook.  An example request body for an email hook for a specific form in your site would be formatted like this:  {   \"site_id\": \"0d3a9d2f-ef94-4380-93df-27ee400e2048\",   \"form_id\": \"5235a7a00d61eec2d6001302\",   \"type\": \"email\",   \"event\": \"submission_created\",   \"data\": { \"email\": \"test@example.com\" } }  form_id is optional and links the hook to a specific form within your site. You can also use form_name with the value of the name attribute of the form of your site as an alternative to form_id.  #Delete hook DELETE /api/v1/hooks/{hook_id} removes a hook permanently.  Note, for outgoing webhooks, returning a 410 Gone status code from the URL endpoint will trigger a deletion of the hook.\n\n\n\nOAuth Quickstart API: 1. Choose a JWT library As your API will be parsing JWT formatted access tokens, you will need to setup these capabilities on your API.  You can navigate to jwt.io  and choose from there. Remember to pick a library that support your selected signing algorithm.  2. Configuring your API to accept RS256 signed tokens Configure the library that will validate the access tokens in your API. Validating a token means that you are certain you can trust its contents.  const express = require('express'); const app = express(); const { auth } = require('express-oauth2-jwt-bearer');  const port = process.env.PORT || 8080;  const jwtCheck = auth({   audience: 'https://carsontkempf.github.io/account/',   issuerBaseURL: 'https://dev-l57dcpkhob0u7ykb.us.auth0.com/',   tokenSigningAlg: 'RS256' });  // enforce on all endpoints app.use(jwtCheck);  app.get('/authorized', function (req, res) {     res.send('Secured Resource'); });  app.listen(port);  console.log('Running on port ', port);\n\n\n\nOAuth Application Settings: Application Settings On the Applications page of the Dashboard, locate your application in the list, and click its name to view the available settings.  Dashboard Applications List Basic settings When you edit an existing application's settings or create a new application, you enter information about the application in the Settings view.  Basic Information Dashboard Applications Application Settings Tab Basic Information Name: The name of your application. Editable, and will be seen in the portal, emails, logs, and so on.  Domain: Your Auth0 tenant name. You choose this when you create a new Auth0 tenant, and it cannot be changed. If you need a different domain, you must register for a new tenant by selecting + Create Tenant in the top-right menu.  Client ID: The unique identifier for your application. You will use this when configuring authentication with Auth0. Generated by the system when you create a new application and cannot be modified.  Client Secret: A string used to sign and validate ID Tokens for authentication flows and to gain access to select Auth0 API endpoints. By default, the value is hidden, so check the Reveal Client Secret box to see it. While the Client ID is considered public information, the Client Secret must be kept confidential. If anyone can access your Client Secret, they can issue tokens and access resources they shouldn't be able to access.  Description: A free-text description of the Application's purpose. Maximum of 140 characters.  Application Properties Dashboard Applications Application Settings Tab Application Properties Application Logo: The URL of a logo (recommended size: 150x150 pixels) to display for the application. Appears in several areas, including the list of applications in the Dashboard and customized consent forms. If none is set the default badge for this type of application will be shown.  Application Type: The Auth0 application type determines which settings you can configure using the Dashboard. (Not editable for M2M apps. Sometimes disabled for other Auth0 application types if the selected grant types are only allowed for the currently selected application type.) Use the drop-down to select from the following types:  Machine to Machine: Non-interactive applications, such as command-line tools, daemons, IoT devices, or services running on your backend. Typically, you use this option if you have a service that requires access to an API.  Native App: Mobile or Desktop applications that run natively in a device (such as iOS or Android).  Regular Web App: Traditional web apps that perform most of their application logic on the server (such as Express.js or ASP.NET).  Single Page App: JavaScript apps that perform most of their user interface logic in a web browser, communicating with a web server primarily using APIs (such as AngularJS + Node.js or React).   Application URIs Dashboard Applications Application Settings Application URIs Application Login URI: In some scenarios, Auth0 will need your application to redirect to your application's login page. This URI needs to point to a route in your application that redirects to your tenant's /authorize endpoint. It would usually take the form of https://myapp.org/login. To learn more, read Configure Default Login Routes.  Allowed Callback URLs: Set of URLs to which Auth0 is allowed to redirect users after they authenticate. You can specify multiple valid URLs by comma-separating them (typically, to handle different environments like QA or testing). For production environments, verify that the URLs do not point to localhost. You can use the star symbol as a wildcard placeholder for subdomains (*.google.com). If you are using the Organizations feature, for production applications, you can use {organization_name} as a placeholder to dynamically specify a registered organization’s name in a URL (https://{organization_name}.exampleco.com). URLs with the {organization_name} placeholder should only be used on domains that you fully control (for example, https://{organization_name}.exampleco.com where you control the exampleco.com domain).  Do not use wildcard placeholders or localhost URLs in your application callbacks or allowed origins fields. Using redirect URLs with wildcard placeholders can make your application vulnerable to attacks. To learn more, read Unvalidated Redirects and Forwards Cheat Sheet on owasp.org. Instead, URLs with the {organization_name} placeholder should be preferred, where relevant. To learn more, read Subdomain URL Placeholders.  Allowed Logout URLs: After a user logs out from Auth0 you can redirect them with the returnTo query parameter. The URL that you use in returnTo must be listed here. You can specify multiple valid URLs by comma-separating them. For production environments, verify that the URLs do not point to localhost. You can use the star symbol as a wildcard placeholder for subdomains (*.google.com). Notice that query strings and hash information are not taken into account when validating these URLs. See Logout. You can provide up to 100 URLs in the Allowed Logout URLs field.  Allowed Web Origins: List of URLs from where an authorization request using Cross-Origin Authentication, Device Flow, and web_message as the response mode can originate from. You can specify multiple valid URLs by comma-separating them. For production environments, verify that the URLs do not point to localhost. You can use the star symbol as a wildcard placeholder for subdomains (*.google.com). Paths, query strings, and hash information are not taken into account when validating these URLs (and may, in fact, cause the match to fail). You can provide up to 100 URLs in the Allowed Web Origins field.  ID Token In the ID Token section, enter the ID Token Expiration (in seconds) which is the amount of time before the Auth0 id_token expires. The default value is 36000 seconds which is 10 hours.   Use Auth0 instead of the IdP to do Single Sign-on: If enabled, this setting prevents Auth0 from redirecting authenticated users with valid sessions to the identity provider (such as Facebook or ADFS). Legacy tenants only.  Refresh Token Rotation In the Refresh Token Rotation section, enable or disable rotation. When enabled, as a result of exchanging a refresh token, a new refresh token will be issued and the existing token will be invalidated. This allows for automatic detection of token reuse if the token is leaked. In addition, enter the Rotation Overlap Period (in seconds). This interval is the allowable leeway time that the same refresh_token can be used to request an access_token without triggering automatic reuse detection. To learn more, read Refresh Token Rotation.  Dashboard Applications Applications Settings Tab Refresh Token Rotation Refresh Token Expiration In the Refresh Token Expiration section, enable or disable absolute and inactivity expiration and set the lifetimes (in seconds) for each. To learn more, read Configure Refresh Token Expiration.  Dashboard Applications Applications Settings Tab Refresh Token Expiration Advanced settings The Advanced Settings section allows you to:  Manage or add application metadata, device, OAuth, and WS-Federation settings  Obtain certificates and Token endpoint information  Set the grant type(s) for the application  Application Metadata Application metadata are custom string keys and values (each of which has a character maximum of 255), set on a per-application basis. Metadata is exposed in the application object as client_metadata, and in rules as context.clientMetadata. You can create up to 10 sets of metadata.  Dashboard Applications Applications Settings Tab Advanced Settings Application Metadata Tab Device Settings If you're developing a mobile application, enter the necessary iOS/Android parameters.  When developing iOS apps, you'll provide your Team ID and App ID. To learn more, read Enable Universal Links Support in Apple Xcode.  When developing Android apps, you'll provide your App Package Name and your Key Hashes. To learn more, read Enable Android App Links Support.  Dashboard Applications Application Settings Tab Advanced Settings Device Settings Tab OAuth Dashboard Applications Application Settings Tab Advanced Settings OAuth Tab By default, all apps/APIs can make a delegation request, but if you want to explicitly grant permissions to selected apps/APIs, you can do so in Allowed Apps/APIs.  For customers using the Highly Regulated Identity add-on, use the Compliance Enforcement Level setting to set your level of compliance. For more information, review Configure FAPI Compliance.  Set the algorithm used ( HS256  or  RS256 ) for signing your JSON web tokens. To learn more, read JSON Web Token Signing Algorithms. When selecting RS256 (recommended), the token will be signed with your tenant's private key.  Toggle the Trust Token Endpoint IP Header setting; if this is enabled, the auth0-forwarded-for is set as trusted and used as a source of end user IP information for protection against brute-force attacks on the Token endpoint. This setting is only available for Regular Web Apps and M2M Apps.  Toggle the switch to indicate if your application is OIDC Conformant or not. Applications flagged as OIDC Conformant will strictly follow the OIDC specification.  For troubleshooting help, read Troubleshoot Invalid Token Errors.  Grant Types Select grant types to enable or disable for your application. Available grant types are based on the application type.  Dashboard Applications Application Settings Tab Advanced Settings Grant Types tab WS-Federation Manage or add WS-Federation settings.  Dashboard Applications Application Settings Tab Advanced WS-Federation tab Certificates Manage or add the signing certificate, and its fingerprint and thumbprint.  Dashboard Applications Advanced Settings Certificates tab Endpoints View endpoint information for OAuth, SAML, and WS-Fed, such as Authorization and Metadata URLs.\n\n\n\nJavascript OAuth Quickstart: JavaScript: Login Gravatar for steve.hobbs@auth0.com By Steve Hobbs This tutorial demonstrates how to add user login to a Javascript application using Auth0.  I want to integrate with my app 15 minutes Configure Auth0 Integrate Auth0 in your Application Setting Up the Application Create the server Initialize the SDK Evaluate the authentication state Log In to the Application Log the User Out Read the User Profile Or I want to explore a sample app 2 minutes Get a sample configured with your account settings or check it out on Github.  New to Auth? Learn How Auth0 works, how it integrates with Single-Page Applications and which protocol it uses.  Configure Auth0 Get Your Application Keys When you signed up for Auth0, a new application was created for you, or you could have created a new one. You will need some details about that application to communicate with Auth0. You can get these details from the Application Settings section in the Auth0 dashboard.  App Dashboard  When using the Default App with a Native or Single Page Application, ensure to update the Token Endpoint Authentication Method to None and set the Application Type to either SPA or Native.  You need the following information:  Domain Client ID If you download the sample from the top of this page, these details are filled out for you.  Configure Callback URLs A callback URL is a URL in your application where Auth0 redirects the user after they have authenticated. The callback URL for your app must be added to the Allowed Callback URLs field in your Application Settings. If this field is not set, users will be unable to log in to the application and will get an error.  If you are following along with the sample project you downloaded from the top of this page, you should set the Allowed Callback URL to http://localhost:3000.  Configure Logout URLs A logout URL is a URL in your application that Auth0 can return to after the user has been logged out of the authorization server. This is specified in the returnTo query parameter. The logout URL for your app must be added to the Allowed Logout URLs field in your Application Settings. If this field is not set, users will be unable to log out from the application and will get an error.  If you are following along with the sample project you downloaded from the top of this page, the logout URL you need to add to the Allowed Logout URLs field is http://localhost:3000.  Configure Allowed Web Origins You need to add the URL for your app to the Allowed Web Origins field in your Application Settings. If you don't register your application URL here, the application will be unable to silently refresh the authentication tokens and your users will be logged out the next time they visit the application, or refresh the page.  If you are following along with the sample project you downloaded from the top of this page, you should set the Allowed Web Origins to http://localhost:3000.    Integrate Auth0 in your Application Use the Auth0 SPA SDK library to integrate Auth0 into your application. You can either install the library as a dependency in your application, or load it from CDN.  Install as a dependency You can install the Auth0 SPA SDK as a dependency of your application, useful if you're using a build system such as Webpack. You can do this using npm or yarn.  # installation with npm npm install --save @auth0/auth0-spa-js  # installation with yarn yarn add @auth0/auth0-spa-js Was this helpful?  / Once the Auth0 SPA SDK is installed, reference it using an import statement at the entrypoint of your application ():  import { createAuth0Client } from '@auth0/auth0-spa-js'; Was this helpful?  / Reference the CDN Alternatively, if you do not use a package manager such as Webpack, you can retrieve the Auth0 SPA SDK from Auth0's CDN.  <script src=\"https://cdn.auth0.com/js/auth0-spa-js/2.0/auth0-spa-js.production.js\"></script> Was this helpful?  / If you encounter some problems or errors when using the new JavaScript SDK, please check out the FAQ to see if your issue is covered there.  Authentication with Auth0 Universal Login is the easiest way to set up authentication in your application. We recommend using it for the best experience, best security and the fullest array of features. This guide will use it to provide a way for your users to log in to your JavaScript application.  You can also embed the login dialog directly in your application using the Lock widget. If you use this method, some features, such as single sign-on, will not be accessible.  When a user logs in, Auth0 returns three items:  access_token: to learn more, see the Access Token documentation id_token: to learn more, see the ID Token documentation expires_in: the number of seconds before the Access Token expires You can use these items in your application to set up and manage authentication.  Setting Up the Application Create a basic HTML page Create a folder on your machine to house the application, then add an index.html file to the root of the project. This HTML page will display a welcome message and have a \"gated\" section which requires the user to be authenticated before accessing. You can copy/paste the following content into the file. You will be adding more lines as you progress with this article.  Add the following content to the index.html file you just created:  <!DOCTYPE html> <html>   <head>     <meta charset=\"UTF-8\" />     <title>SPA SDK Sample</title>     <link rel=\"stylesheet\" type=\"text/css\" href=\"/css/main.css\" />   </head>    <body>     <h2>SPA Authentication Sample</h2>     <p>Welcome to our page!</p>     <button id=\"btn-login\" disabled=\"true\" onclick=\"login()\">Log in</button>     <button id=\"btn-logout\" disabled=\"true\" onclick=\"logout()\">Log out</button>   </body> </html> Was this helpful?  / Additionally, create a new folder called public, a folder inside that called css and a new file in there called main.css. This will be used to define how the gated content elements will be hidden in the page.  Open the newly-created public/css/main.css file and add the following CSS:  .hidden {   display: none; }  label {   margin-bottom: 10px;   display: block; } Was this helpful?  / Finally, create a new directory in the public folder called js, and a new file in there called app.js. This will house the application-specific logic that you will create over the next few sections.  The folder structure so far should look like the following:  . ├── index.html └── public     ├── css     │   └── main.css     └── js         └── app.js Was this helpful?  / Reference the SDK This article is based on the new SPA SDK available here. You can reference the package from the CDN in the index.html file by placing the script tags at the very bottom of the body tag:  <body>      <!-- other HTML -->      <!-- add the lines below existing code -->   <script src=\"https://cdn.auth0.com/js/auth0-spa-js/2.0/auth0-spa-js.production.js\"></script>   <script src=\"js/app.js\"></script> </body> Was this helpful?  / Configure credentials Create an auth_config.json in the root of the project. The values from domain and clientId should be populated from your Auth0 application settings as configured above.  {   \"domain\": \"dev-l57dcpkhob0u7ykb.us.auth0.com\",   \"clientId\": \"Dq4tBsHjgcIGbXkVU8PPvjAq3WYmnSBC\" } Was this helpful?  / As auth_config.json is served publicly, this file should never contain sensitive information such as passwords and client secrets.  Create the server In this section you will create a basic web server using ExpressJS. This will be used to serve our HTML page, along with any assets that it requires (JavaScript, CSS, etc).  Run the following command in the same folder as the index.html file you created earlier:  npm init -y Was this helpful?  / This will initialize a new NPM project and get us ready to install dependencies.  Installing dependencies In the terminal, install the dependencies that are necessary to get the server up and running:  npm install express Was this helpful?  / Also install  nodemon  so that our server can be restarted on any code changes:  npm install -D nodemon Was this helpful?  / Finally, open the package.json file and modify the \"scripts\" entry to look like the following:  {   // ...   \"scripts\": {     \"start\": \"node server.js\",     \"dev\": \"nodemon server.js\"   },   // ... } Was this helpful?  / npm start will run the application as normal npm run dev will run the application using nodemon, watching for changes as we modify files Creating server.js Next, create a new file in the root of the project alongside index.html and package.json, called server.js. This will be our backend server and will be used to serve the SPA pages.  Populate server.js with the following code:  const express = require(\"express\"); const { join } = require(\"path\"); const app = express();  // Serve static assets from the /public folder app.use(express.static(join(__dirname, \"public\")));  // Endpoint to serve the configuration file app.get(\"/auth_config.json\", (req, res) => {   res.sendFile(join(__dirname, \"auth_config.json\")); });  // Serve the index page for all other requests app.get(\"/*\", (_, res) => {   res.sendFile(join(__dirname, \"index.html\")); });  // Listen on port 3000 app.listen(3000, () => console.log(\"Application running on port 3000\")); Was this helpful?  / The server provides two endpoints:  one which serves the authentication configuration file to the client-side app another which serves every other request to the index.html file, which will provide support for any client-side routing as all routes go to the same page The app also serves all of the static files, such as the .js and .css files from the /public folder.  Initialize the SDK The SDK must be properly initialized with the information of the Auth0 application created above.  To start, open the public/js/app.js file and add a variable to hold the Auth0 client object:  let auth0Client = null; Was this helpful?  / This must be initialized using the values from the auth_config.json file. This can be done by calling the endpoint on the server that was created in the previous section. To do this, create a new function called fetchAuthConfig further down the app.js file, which can be used to download this information:  // ..  const fetchAuthConfig = () => fetch(\"/auth_config.json\"); Was this helpful?  / Next, create another new function called configureClient. This will use fetchAuthConfig to download the configuration file and initialize the auth0Client variable:  // ..  const configureClient = async () => {   const response = await fetchAuthConfig();   const config = await response.json();    auth0Client = await auth0.createAuth0Client({     domain: config.domain,     clientId: config.clientId   }); }; Was this helpful?  / This call will also populate the in-memory cache with a valid access token and user profile information if someone has already authenticated before and that session is still valid.  Add a handler for the window.onload function that will then make this call to initialize the application:  // ..  window.onload = async () => {   await configureClient(); } Was this helpful?  / Now go and access it at http://localhost:3000. You should see the welcome message and both authentication buttons disabled. Note however that some browsers cache the page sources. When checking each step results you should perform a full page refresh ignoring the cache. This can be achieved by using the CMD+SHIFT+R keys on OSX and CTRL+SHIFT+R keys on Windows.  Restoring Login State with Social Providers Users who are logged in with username/password will be silently reauthenticated automatically when the application reloads. No further action is needed for this type of login.  If you are using the classic Universal Login experience and would like users to authenticate using  social identity providers  (such as Google, Apple, Facebook, etc.), then you will need to configure those connections in your Auth0 Dashboard.  In the navigation menu, choose Connections - Social, and select the social connection you’d like to support. In the connection’s settings, click “How to obtain a Client ID?“ and follow the instructions to set up your own ID and secret.  If you are using the new Universal Login experience, the default enabled social connections will silently reauthenticate without additional configuration. However, you should still set up your own keys and avoid using default Auth0 development keys in a production app.  Evaluate the authentication state As a first approach, you want to make sure anyone is able to visit the public page but not the page that is meant for authenticated users only, such as a settings panel or the user profile details. You can decide which content is available by hiding, disabling, or removing it if no user is currently logged in. You do so by checking the result of calling the auth0Client.isAuthenticated() method. Use this to enable or disable the Log in and Log out buttons, which are disabled by default. This can be part of a new updateUI() function called from the window.onload method right after the initialization.  Still inside the app.js file, add a new function called updateUI and modify the onload handler to call this new function:  // ..  window.onload = async () => {   await configureClient();    // NEW - update the UI state   updateUI(); };  // NEW const updateUI = async () => {   const isAuthenticated = await auth0Client.isAuthenticated();    document.getElementById(\"btn-logout\").disabled = !isAuthenticated;   document.getElementById(\"btn-login\").disabled = isAuthenticated; }; Was this helpful?  / Checkpoint: If you run the project again, you should see that the \"Log in\" button is shown as enabled as no user has previously logged in. But clicking it will not do anything as there is no logic associated to that action yet.  Log In to the Application Authentication is achieved through a redirect to the Auth0 Universal Login Page. Once the user signs up or logs in, the result will be passed to your app's redirect URI, which is provided with the authorization request.  Inside the app.js file, provide a login function that calls auth0Client.loginWithRedirect() to perform the login step. The login function is called by the Log in button previously defined in the HTML page. In this sample, you will redirect the user back to the same page they are now. You can obtain that value from window.location.origin property:  // ..  const login = async () => {   await auth0Client.loginWithRedirect({     authorizationParams: {       redirect_uri: window.location.origin     }   }); }; Was this helpful?  / Additionally, because this is a single page application, the result of this call needs to be handled in the same context. This means that when the page is loaded and the user is not authenticated you could be in one of the following two scenarios:  The user does not want to authenticate and is just navigating through public content or The user has recently initiated the authentication process and is now looking to complete it. This second scenario is the one you need to handle. In your window.onload method, check whether the user is authenticated or not, and if the URL query contains both a code and state parameter. This will indicate that an authentication result is present and needs to be parsed. In that scenario, you do so by calling the auth0Client.handleRedirectCallback() method. This will attempt to exchange the result that the Auth0 backend gave you back for real tokens you can use.  In addition, the query parameters must be removed from the URL so that if the user refreshes the page, the app does not try to parse the state and code parameters again. This is achieved with the window.history.replaceState method.  Modify the window.onload function inside app.js to include these changes:  // ..  window.onload = async () => {    // .. code ommited for brevity    updateUI();    const isAuthenticated = await auth0Client.isAuthenticated();    if (isAuthenticated) {     // show the gated content     return;   }    // NEW - check for the code and state parameters   const query = window.location.search;   if (query.includes(\"code=\") && query.includes(\"state=\")) {      // Process the login state     await auth0Client.handleRedirectCallback();          updateUI();      // Use replaceState to redirect the user away and remove the querystring parameters     window.history.replaceState({}, document.title, \"/\");   } };  // .. Was this helpful?  / The callback is now handled properly and the authentication can be completed successfully.  Run the project and click the Log in button. You should be taken to the Universal Login Page configured for your application. Go ahead and create a new user or log in using a social connection. After authenticating successfully, you will be redirected to the page you were before. This time, the result will be present in the URL query and the exchange will happen automatically. If everything went fine, you will end up with no query parameters in the URL, the user would now be logged in and the \"Log out\" button will be enabled.  If you see any errors from the Auth0 server, check that you have not forgotten to register the callback URL or the allowed origins as explained initially.  Log the User Out You may have noticed that the Log out button is clickable when the user is authenticated, but does nothing. You need to add the code that will log the user out from the Auth0 backend.  Start the log out by calling the auth0Client.logout() method passing a valid return-to URI. In this sample you will return the user back to the same page they are now. You can obtain that value from window.location.origin property. Abstract this logic into a logout() method.  // public/js/app.js  const logout = () => {   auth0Client.logout({     logoutParams: {       returnTo: window.location.origin     }   }); }; Was this helpful?  / Checkpoint: Being authenticated click the Log out button. You should be taken to the Universal Login Page configured for your application and then back to the page you were before. Now the authentication cookies were cleared and the user is logged out. The \"Log in\" button will be enabled back again.  If you see any errors from the Auth0 server, check that you have not forgotten to register the logout URL as explained initially.  Read the User Profile Every time a user is logged in you get access both to the access token and the ID token. The user's profile information is then extracted from the ID token. Typically, the token is used to call your backend application and the profile information is used to display their name and profile picture. In this section you are going to display them in separate text areas so you can easily inspect them.  Open the index.html file and insert the following lines at the bottom of the body.  <body>   <!-- ... -->    <div class=\"hidden\" id=\"gated-content\">     <p>       You're seeing this content because you're currently       <strong>logged in</strong>.     </p>     <label>       Access token:       <pre id=\"ipt-access-token\"></pre>     </label>     <label>       User profile:       <pre id=\"ipt-user-profile\"></pre>     </label>   </div>      <!-- .. existing script tags .. --> </body> Was this helpful?  / Now re-open the app.js file and modify the updateUI() function declared previously. Add the logic such that when the user is logged in the gated content is shown. Use the existing variables and functions from the SDK client to obtain and display this information on the page.  In addition, at the start of this article you added a public/css/main.css file with the definition of the hidden class, which can be used to easily hide elements on the page. Using the authenticated flag as shown below, add or remove this class to the elements you want to show or hide in the updateUI() function:  // ...  const updateUI = async () => {    const isAuthenticated = await auth0Client.isAuthenticated();    document.getElementById(\"btn-logout\").disabled = !isAuthenticated;   document.getElementById(\"btn-login\").disabled = isAuthenticated;      // NEW - add logic to show/hide gated content after authentication   if (isAuthenticated) {     document.getElementById(\"gated-content\").classList.remove(\"hidden\");      document.getElementById(       \"ipt-access-token\"     ).innerHTML = await auth0Client.getTokenSilently();      document.getElementById(\"ipt-user-profile\").textContent = JSON.stringify(       await auth0Client.getUser()     );    } else {     document.getElementById(\"gated-content\").classList.add(\"hidden\");   } };  // .. Was this helpful?  / Note that calls to the SDK instance can throw an exception if the authentication fails, if there is no user currently authenticated, or if the access token needs to be refreshed and that request fails. You will need to put a try/catch block around them to correctly handle any errors. These error checks are not shown on the article but they are available on the final sample app that you can download.\n\n\n\nOAuth Calling an API: JavaScript: Calling an API Gravatar for steve.hobbs@auth0.com By Steve Hobbs This tutorial demonstrates how to make API calls for protected resources on your server.  I want to integrate with my app 15 minutes Create an API Create a Backend API Calling the API Or I want to explore a sample app 2 minutes Get a sample configured with your account settings or check it out on Github.  Most single-page apps use resources from data APIs. You may want to restrict access to those resources, so that only authenticated users with sufficient privileges can access them. Auth0 lets you manage access to these resources using API Authorization.  This tutorial shows you how to access protected resources in your API.  This tutorial does not show you how to add protection to your API. Read the Backend/API quickstart documentation for instructions on how to protect your API.  Create an API In the APIs section of the Auth0 dashboard, click Create API. Provide a name and an identifier for your API. You will use the identifier later when you're configuring your Javascript Auth0 application instance. For Signing Algorithm, select RS256.  Create API  Create a Backend API In this section, you will modify the ExpressJS that you created in part 1 so that it supports a new endpoint. This endpoint will require a valid access token to be sent in the Authorization header for the call to be successful.  Add middleware to the backend To begin, let's install an NPM package that will be used to validate incoming tokens to the server. From the terminal:  npm install express-oauth2-jwt-bearer Was this helpful?  / Next, open server.js and bring in these libraries as imports at the top of the file. Also bring in the auth_config.json file so that the script can get access to the authentication credentials that have been configured:  // .. other imports  const { auth } = require(\"express-oauth2-jwt-bearer\"); const authConfig = require(\"./auth_config.json\"); Was this helpful?  / express-oauth2-jwt-bearer  - validates JWTs from the authorization header and sets the req.auth object Then add a call to auth(), which creates the middleware needed in order to validate and parse incoming access tokens. This should go after the require statements but before any routes are defined in your app:  // create the JWT middleware const checkJwt = auth({   audience: authConfig.audience,   issuerBaseURL: `https://${authConfig.domain}` }); Was this helpful?  / This code configures the express-oauth2-jwt-bearer middleware with the settings that relate to your Auth0 application.  Next, open the auth_config.json file and modify the data so that the audience appears as a key within the JSON, using the value that you just used when creating the API:  Configured withApplication:CarsonKempf CarsonKempf API:CarsonKempf CarsonKempf {   \"domain\": \"dev-l57dcpkhob0u7ykb.us.auth0.com\",   \"clientId\": \"moH0QbZSCdnwIryD7FoElVSs3kEvUHbH\",   \"audience\": \"https://carsontkempf.github.io/account/\" } Was this helpful?  / As auth_config.json is served publicly, this file should never contain sensitive information such as passwords and client secrets.  The values for domain and clientId should have already been specified as part of the Login tutorial. They should point to the Domain and Client ID values for your Auth0 app respectively.  Add a protected endpoint The last thing to do on the server side is to add an API endpoint that requires an access token to be provided for the call to succeed. This endpoint will use the middleware that you created earlier in the tutorial to provide that protection in a scalable way.  Open server.js and add a new route for /api/external above the other routes that returns some JSON:  // ..  app.get(\"/api/external\", checkJwt, (req, res) => {   res.send({     msg: \"Your access token was successfully validated!\"   }); });  // .. Was this helpful?  / Note that checkJwt is used as the second argument here. This causes checkJwt to be executed before the main route handler, and will reject the call and return a 401 response if:  there is no access token present in the Authorization header, or the token itself is not valid Finally, add an error handler so that a JSON response is returned from your API in the event of a missing or invalid token:  // ..  app.use(function(err, req, res, next) {   if (err.name === \"UnauthorizedError\") {     return res.status(401).send({ msg: \"Invalid token\" });   }    next(err, req, res); });  //.. Was this helpful?  / At the end, your server.js file will look something like the following:  const express = require(\"express\"); const { auth } = require(\"express-oauth2-jwt-bearer\"); const { join } = require(\"path\"); const authConfig = require(\"./auth_config.json\");  const app = express();  // Serve assets from the /public folder app.use(express.static(join(__dirname, \"public\")));  // Create the JWT validation middleware const checkJwt = auth({   audience: authConfig.audience,   issuerBaseURL: `https://${authConfig.domain}` });  // Create an endpoint that uses the above middleware to // protect this route from unauthorized requests app.get(\"/api/external\", checkJwt, (req, res) => {   res.send({     msg: \"Your access token was successfully validated!\"   }); });  // Serve the auth configuration file app.get(\"/auth_config.json\", (req, res) => {   res.sendFile(join(__dirname, \"auth_config.json\")); });  // Serve the index page to everything else app.get(\"/*\", (req, res) => {   res.sendFile(join(__dirname, \"index.html\")); });  // Error handler app.use(function(err, req, res, next) {   if (err.name === \"UnauthorizedError\") {     return res.status(401).send({ msg: \"Invalid token\" });   }    next(err, req, res); });  module.exports = app; Was this helpful?  / Test the API With this in place, run the application using npm run dev. In another terminal window, use the curl tool to make a request to this API endpoint and observe the results:  curl -I localhost:3000/api/external Was this helpful?  / You should find that a 401 Unauthorized result is returned, because it requires a valid access token:  HTTP/1.1 401 Unauthorized X-DNS-Prefetch-Control: off X-Frame-Options: SAMEORIGIN Strict-Transport-Security: max-age=15552000; includeSubDomains X-Download-Options: noopen X-Content-Type-Options: nosniff X-XSS-Protection: 1; mode=block Content-Security-Policy: default-src 'self' Content-Type: text/html; charset=utf-8 Content-Length: 1582 Date: Wed, 03 Apr 2019 13:10:43 GMT Connection: keep-alive Was this helpful?  / Calling the API Now you can turn your attention to the front-end application. You will update the application to provide a button to call a function which will in turn call the API that you created in the previous section.  Open index.html and add a new button that will invoke the API call, as well as a pre element with an ID of api-call-result to show the result of the API call in the browser:  <button id=\"btn-call-api\" disabled=\"true\" onclick=\"callApi()\">Call Api</button>  <!-- Add a container to hold the response from the call --> <pre id=\"api-call-result\"></pre> Was this helpful?  / Next, open public/js/app.js. Configure the auth0 client object to specify the audience value that was added earlier to the auth_config.json file:  const configureClient = async () => {   const response = await fetchAuthConfig();   const config = await response.json();    auth0 = await auth0Client.createAuth0Client({     domain: config.domain,     clientId: config.clientId,     authorizationParams: {       audience: config.audience   // NEW - add the audience value     }   }); }; Was this helpful?  / Add a new function called callApi to app.js, with the following content:  const callApi = async () => {   try {      // Get the access token from the Auth0 client     const token = await auth0Client.getTokenSilently();      // Make the call to the API, setting the token     // in the Authorization header     const response = await fetch(\"/api/external\", {       headers: {         Authorization: `Bearer ${token}`       }     });      // Fetch the JSON result     const responseData = await response.json();      // Display the result in the output element     const responseElement = document.getElementById(\"api-call-result\");      responseElement.innerText = JSON.stringify(responseData, {}, 2);  } catch (e) {     // Display errors in the console     console.error(e);   } }; Was this helpful?  / Finally, find the updateUI function within app.js and modify it so that the button for calling the API is enabled when the user logs in:  // public/js/app.js  const updateUI = async () => {   const isAuthenticated = await auth0Client.isAuthenticated();    document.getElementById(\"btn-logout\").disabled = !isAuthenticated;   document.getElementById(\"btn-login\").disabled = isAuthenticated;    // NEW - enable the button to call the API   document.getElementById(\"btn-call-api\").disabled = !isAuthenticated;    // .. other code omitted for brevity .. }; Was this helpful?  / Now, open the browser in the application at http://localhost:3000. If the application has been stopped, run it again from the terminal using npm run dev.  When the application starts, log in. Then, press the Call API button to make a request to the API and put the results on the screen. You should find that the result from the server is displayed on the page.\n\n\n\nRedirect Users: Redirect Users You can return users to specific pages (URLs) within your application after validating their ID Tokens (authentication). To see an example of how this works, try the React: Login Quickstart.  Redirect users to callback URLs on the AllowList Because callback URLs can be manipulated by unauthorized parties, Auth0 recognizes only URLs on the AllowList set in the Allowed Callback URLs field of an Application's Settings as valid. To return users to callback URLs on the AllowList, it is necessary for your application to know how to continue the user on their journey.  There are two methods for doing this:  Using cookies and browser sessions  Using state parameters  During a user's authentication, the redirect_uri request parameter is used as a callback URL. This is where your application receives and processes the response from Auth0, and is often the URL to which users are redirected once the authentication is complete. To learn more about how the redirect_uri works, see OAuth 2.0 Authorization Framework.   You can use a cookie or the browser session to store a return URL value. This is a simple solution to implement, however, it can cause issues in cases where a cookie does not persist. There are two separate user sessions initiated in this situation. Each serves a separate purpose and requires some consideration to achieve the desired user experience.  Auth0-provided SSO Session: Auth0 provides a session for enabling Single Sign On (SSO) to allow your user to maintain an authentication session without being prompted for credentials more than once. This session is maintained by Auth0 and referenced as a cookie bound to your tenant domain (or CNAME). There are two tenant settings that determine the length of the Auth0 Session:  The idle_session_lifetime is how long the session will remain alive without interaction.  The session_lifetime is the maximum duration that the session is allowed to remain alive.  These settings apply to all applications within your tenant and should be configured to align with the security model that matches your use case.  Application Session: Your application must also maintain a concept of a session. Throughout the user session, your application may need to request additional tokens or renew expired ones. You should store these tokens in your application and reference them using an identifier passed back to the browser using a secure cookie.  Once your user has authenticated with Auth0 it is up to your application to determine how long it persists this session.  Redirect users to other URLs Sometimes, the callback URL is not necessarily where you want users redirected after authentication. For example, if a user intends to access a protected page in your application, and that action triggers the request to authenticate, you can store that URL to redirect the user back to their intended page after the authentication finishes. Store the desired URL using the following methods:  Redirect users with state parameters  Redirect users from within rules  Choose the option that works best for your application type and the type of flow that you are using. Create the necessary logic in your application to retrieve the stored URL and redirect your users where you want them to go. The Auth0 SDKs also include support for redirect URLs.\n\n\n\nAuth0 Actions: Understand How Auth0 Actions Work Actions are secure, tenant-specific, versioned functions written in Node.js that execute at certain points within the Auth0 platform. Actions are used to customize and extend Auth0's capabilities with custom logic.  Auth0 Actions uses modern JavaScript's promise-based programming model, a basis for asynchronous functions in Actions.  The processes that can be extended in this way are called triggers. Trigger groupings represents the logical pipeline through which information moves during a single point in the Auth0 journey. Multiple Actions can be added to a trigger, with each Action executing in the order in which it was placed. Some triggers are executed synchronously, blocking the flow in which they are involved, and some are executed asynchronously, as indicated in the table below.  Actions are a cornerstone to our overall extensibility product at Auth0. With Actions, you can add essential custom logic to your login and identity flows specific to your needs. Actions also allow you to connect external integrations that enhance your overall extensibility experience. For example, you can add an Action to your login trigger to verify credentials such as a License or Passport using a Marketplace Partner who specializes in identity proofing.  What can you do with Actions? What an Action can do is determined by where it is executed within the Auth0 runtime environment.  /  Trigger\tDescription pre-user-registration\tTriggers before a user is created. Does not run for social connections. post-user-registration\tTriggers asynchronously after a user is created. Does not run for social connections. post-login\tTriggers after a user is authenticated but token hasn't issued. /  /  Trigger\tDescription post-change-password\tTriggers after a password is changed. Does not run for Social connections. password-reset-post-challenge\tTriggers after the first challenge is completed and before the password is reset. /  Key benefits of Actions Improved developer experience When editing an Action within the Auth0 Dashboard, you will have access to rich type information and inline documentation about what is possible within each trigger, which makes it easy to discover what capabilities each Trigger supports.  An Action can be edited and tested without affecting the version that is currently serving production traffic.  If an issue is found within an Action, it can be rolled back to a previous version.  Access to npm packages Nearly all public npm packages are available to be used within Actions.  Observability When Actions are executed, Auth0 will capture key metrics about them and link them to Auth0 Logs.  Multiple Actions on every trigger Every Action trigger supports multiple independent Actions.\n\n\n\nOauth Login Trigger: Login Trigger The Login trigger executes when a user successfully authenticates against an application on an Auth0 tenant. This also includes post-signup authentication.  Diagram showing the Actions Login Flow. Actions in this trigger are blocking (synchronous), which means they execute as part of a trigger's process and prevent the rest of the Auth0 pipeline from running until the Action is complete.  Triggers Login / Post Login The post-login trigger is a function executed after a user logs in and when a Refresh Token is requested.  References Event object: Provides contextual information about a single user logging in via Auth0.  API object: Provides methods for changing the behavior of the flow.  Common use cases Access control A post-login Action can be used to provide custom logic used to deny access to a user who is attempting to access an application:  /**  * @param {Event} event - Details about the user and the context in which they are logging in.  * @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.  */ exports.onExecutePostLogin = async (event, api) => {   if (event.user.email && event.user.email.endsWith(\"@example.com\") && event.client.name === \"My SPA\") {     api.access.deny(`Access to ${event.client.name} is not allowed.`);   } }; Was this helpful?  / Allow access only on weekdays for a specific application If you have an application that you want to make sure is only accessible during weekdays, you can create the following Action:  /**  * @param {Event} event - Details about the user and the context in which they are logging in.  * @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.  */  exports.onExecutePostLogin = async (event, api) => {   if (event.client.name === \"APP_NAME\") {     const d = new Date().getDay();      if (d === 0 || d === 6) {       api.access.deny(\"This app is only available during the week.\");     }   } } Was this helpful?  / Deny access to anyone calling an API Let's say you want to deny access to all users who are calling an API. This means that you need to deny access depending on the audience value for your API, which you can find in the API Audience field of your API in Dashboard > Applications > APIs. To do this, you would create the following Action:  /**  * @param {Event} event - Details about the user and the context in which they are logging in.  * @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.  */  exports.onExecutePostLogin = async (event, api) => {   // In Actions, an API will be referred to as a Resource Server.   if (event.resource_server && event.resource_server.identifier === \"http://todoapi2.api\") {     api.access.deny(\"end_users_not_allowed\");   } } Was this helpful?  / Add user roles to ID and Access tokens To add user roles to Auth0-issued tokens, use the event.authorization object along with the api.idToken.setCustomClaim and api.accessToken.setCustomClaim methods:  /**  * @param {Event} event - Details about the user and the context in which they are logging in.  * @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.  */ exports.onExecutePostLogin = async (event, api) => {   const namespace = 'https://my-app.example.com';   if (event.authorization) {     api.idToken.setCustomClaim(`${namespace}/roles`, event.authorization.roles);     api.accessToken.setCustomClaim(`${namespace}/roles`, event.authorization.roles);   } } Was this helpful?  / A custom claim cannot include certain terms, and we strongly recommend using namespaced claim that takes the form of a URI. See our documentation on custom claims for more information.  The JWT returned to the requesting application is built and signed at the end of the trigger processing. The final, signed JWT is not accessible in an Action.  Enrich the user profile Auth0 provides a system for storing metadata on a User Profile. In order to set user_metadata or app_metadata on a user’s profile during their login, use the api.user.setUserMetadata or api.user.setAppMetadata functions.  /**  * @param {Event} event - Details about the user and the context in which they are logging in.  * @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.  */ exports.onExecutePostLogin = async (event, api) => {   api.user.setUserMetadata(\"favorite_color\", \"blue\"); }; Was this helpful?  / Once all post-login actions have been executed, Actions will update the user profile in a single operation. This operation is subject to the \"Write Users\" rate limit.  Enforce custom MFA policy A post-login Action can be used to dynamically require MFA for a user according to your application’s needs.  /**  * @param {Event} event - Details about the user and the context in which they are logging in.  * @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.  */ exports.onExecutePostLogin = async (event, api) => {   // Require MFA for anyone logging in from North America.   if (event.request.geoip.continentCode === \"NA\") {     api.multifactor.enable(\"any\");   }; }; Was this helpful?  / An MFA Provider must be configured in order to enable MFA during a login. To learn more, read Multi-Factor Authentication.  Reduce friction with passkeys A post-login Action can be used to reduce the friction by dynamically skipping MFA for a user that has authenticated with a passkey.  /** * Handler that will be called during the execution of a PostLogin flow. * * @param {Event} event - Details about the user and the context in which they are logging in. * @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login. */ exports.onExecutePostLogin = async (event, api) => {  // Check if a passkey was used to authenticate  const skipMFA = event.authentication?.methods.some(    (method) => method.name === \"passkey\"  );   // If a passkey was used skip MFA  if (skipMFA) {    api.multifactor.enable(\"none\");  } }; Was this helpful?  / The connection must have passkeys and MFA enabled. To learn more, read Passkeys and Multi-Factor Authentication.  Redirect the user to an external site Similar to Redirect Rules, a post-login Action can be used to send the user to an external site. When completed, the user can be redirected back to Auth0 to continue their login flow. In the example below, a Redirect Action is used to prompt the user to provide their favorite color.  /**  * @param {Event} event - Details about the user and the context in which they are logging in.  * @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.  */ exports.onExecutePostLogin = async (event, api) => {   // Skip the redirect if the user has already chosen a favorite color.   if (event.user.user_metadata.favorite_color) {     return;   }    const token = api.redirect.encodeToken({     secret: event.secrets.MY_SHARED_SECRET,     payload: {       email: event.user.email,     },   });    // Send the user to https://my-app.example.com along   // with a `session_token` query string param.   api.redirect.sendUserTo(\"https://my-app.example.com\", {      query: { session_token: token }   }); };  /**  * @param {Event} event - Details about the user and the context in which they are logging in.  * @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.  */ exports.onContinuePostLogin = async (event, api) => {   // Once the /continue endpoint has been called, unpack the signed token   // and store the favorite color as user metadata.    const payload = api.redirect.validateToken({     secret: event.secrets.MY_SHARED_SECRET,   });    api.user.setUserMetadata(\"favorite_color\", payload.favorite_color); }; Was this helpful?  / The Actions pipeline will be suspended while the user is redirected. Once the user continues their Auth0 login process, the Actions pipeline will resume where it was suspended. Actions that were executed prior to the Redirect will not be executed again.  To learn more about Redirect Actions, read Redirect with Actions.  Modify scopes on an access token When modifying the scopes associated with an access token, ensure you adhere to the best practices surrounding audience specification.  Always check for expected audience before adding scopes.  Prevent using untrusted input when adding scopes.  /**  * @param {Event} event - Details about the user and the context in which they are logging in.  * @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.  */ exports.onExecutePostLogin = async (event, api) => {   if (event.request.query.audience === 'https://example.com/api') {     api.accessToken.addScope(\"read:xyz\");   } }; Was this helpful?  / Learn more\n\n\n\nJest Documentation:  vscode-jest Build Status Coverage Status Visual Studio Marketplace  Getting Started This extension supports full jest features in vscode environment to make testing more intuitive and fun. It should work out-of-the-box for most common jest projects. To get started:  Setup jest in your project if you haven't. install \"Jest\" extension in vscode. reload or restart vscode If the extension can find the jest command, by default it will automatically run and monitor all tests in watch mode upon launch, and you should see tests, status, errors, coverage (if enabled) in TestExplorer and editors like this:  image  If you have a more sophisticated project configuration or prefer to run tests differently, fear not, the extension supports extensive customization settings. For example:  you can use jest.jestCommandLine to tell the extension to use yarn test instead of the default jest command. you can use jest.runMode to optimize performance and control when the extension should run your tests. you can use the extension with monorepo projects, see monorepo project support for details. You can see the full features and learn more details in the How-To section. If you encounter an unexpected error, feel free to checkout the Troubleshooting or file an issue.  Happy testing!  Releases Current (v6.4.3): release note Previous (v6.4.0): release note All: Release Notes  Content  vscode-jest Getting Started Releases Features Installation User Interface How To? How to set up the extension? How to change runMode for the current session? How to trigger a test run? How to debug tests? How to use code coverage? How to read coverage scheme and customize it How to update and view snapshots How to use the extension with monorepo projects? How to read the StatusBar? How to perform Quick-Fix? How to see more debug info (self-diagnosis)? Customization Settings jestCommandLine rootPath coverageFormatter coverageColors outputConfig runMode autoRun testExplorer shell monitorLongRun autoRevealOutput parserPluginOptions virtualFolders Debug Config Debug Config v2 Commands Menu Troubleshooting Jest failed to run Performance issue? Intermittent errors for (npm/yarn/node) command not found during test run or debugging I don't see \"Jest\" in the bottom status bar What to do with \"Long Running Tests Warning\" The tests and status do not match or some tests showing question marks unexpectedly? Want to Contribute? License Features Starts Jest automatically for most projects with runnable jest configurations. Supports monorepo, react, react-native, angular, vue and various configurations/platforms. Supports running multiple jest processes within the same workspace folder. Fully integrated with the vscode TestExplorer. Help debug jest tests in vscode. View and update snapshots interactively. Show coverage information in files being tested. Supports both automatic and manual test runs at any level, and easy-switch via UI. Supports additional IntelliSense for jest methods. Show fails inline of the expect function, as well as in the problem inspector. active community support. Installation Simply open Visual Studio Code, go to the extension view and search for \"Jest\". Alternatively, open Jest - Visual Studio Marketplace and click \"Install\".  For detailed releases and migration help, please see releases.  User Interface This extension fully integrates with the VSCode testing framework, supporting both automatic and on-demand test runs. In addition to the standard VSCode Test Explorer interface, the extension provides additional UI elements to simplify the development workflow:  interface-6.1.0.png Dynamic Run Mode: Run mode dictates the overall user experience, determining when tests should run, with or without coverage, error display style, etc. Different run modes may have different performance implications, particularly for larger projects.  We realized that runMode preference could change even within a given project, for example developers prefer \"watch\" runMode when doing light code changes to ensure nothing breaks, may prefer the 'on-demand' mode during heavy test development for greater control over test execution. A static runMode config in \"settings.json\" is simply not sufficient. Therefore, we added the runMode quick switch so users can easily switch to different runMode without permanently modifying the \"settings.json\".   Interactive Test Run: Besides automatic test executions (\"watch\", \"on-save\"), users can initiate full test actions, such as run, debug, update/view snapshot, from both editor and Test Explorer through various UI components.   Test Output: The extension offers native jest run outputs in both the \"TERMINAL\" and \"TEST RESULTS\" panel. \"TEST RESULTS\" panel mainly displays test run output in execution order, while \"TERMINAL\" groups test output by workspace folder/virtual-folder, and also includes extension configuration details, quick-fix suggestions, etc. By default, the output appears when tests run, but this can be adjusted via the outputConfig setting.   Extension Status: Upon successful launch of the extension, the status bar shows the run status for the active folder, and the aggregated test status for the whole workspace. Clicking on each status reveals the associated output window.  How To? How to set up the extension? Hopefully, you don't have to do anything. If you can run jest from the terminal, you should be able to use this extension.  The extension will try to auto-config a jest command and debug config when needed. If the auto-config fails, or any non-test error occurred, users should see an quick-fix-chooser link in the output terminal to help resolving the issues.  For more details see the setup tool and the complete customization options in settings.  How to change runMode for the current session? To adjust the runMode during your current session:  Click on the runMode buttons referenced in the User Interface section. This action will prompt a runMode chooser.  Within the chooser, you can swiftly switch the runMode type, toggle coverage, opt for deferred mode, or directly edit the runMode within an editor.  runMode Chooser Interface Confirm your adjustments by clicking the \"Apply\" button located on the top right. Or discard changes with the \"Return\" button on the top left. Note: Changes to runMode using the UI will apply only to the ongoing session. Upon restarting the extension or reloading the window, the runMode will revert to the value in settings.json. However, you can write the current runMode value to settings.json with command: \"Jest: Save Current RunMode\" via command palette.  For an in-depth understanding of each type and the available options, refer to runMode.  How to trigger a test run? By default, the extension uses jest watch mode that automatically runs tests upon related file changes. In addition, users can also trigger individual tests/suites on-demand:  run-test trigger test runs via the gutter menu of each test and describe blocks. trigger test runs via the TestExplorer tree item's inline menu. trigger test runs via command palette, such as Jest: Run All Tests trigger test runs via the editor context menu: Jest: Run Related Tests The extension will try to auto-config a jest runner, if it fails, you can try the quick-fix-chooser.  How to debug tests? There are 2 ways to debug a specific test:  run-debug via the editor gutter context menu via the test tree item inline menu The extension will try to generate a debug config, but if you encounter a debug error or want to change the configuration, please see Customization - Debug Config.  How to use code coverage? v6.3.0 and up  Test coverage can also be run interactively via the TestExplorer tree view, by clicking the \"Run with Coverage\" button.  test-coverage-explorer v6.2.5 and below  [!Note] Note: The following describes the original test coverage feature, which remains available as of 2024/08/13. With the introduction of the new, more intuitive integration in v6.3.0, we plan to deprecate this feature soon. If you have any concerns or would like to share your thoughts on this change, please let us know.  Code coverage can be triggered via  change runMode config via chooser or settings. Command Palette, select command like Jest: Toggle Coverage to activate or deactivate code coverage (see full list in commands. The coverage stats will be displayed at the source code editor: summary at the top and inline coverage indicator based on the formatter selected.  coverage-screen-shot To verify the coverage mode is on, one can check the runMode chooser or the status bar (see how to read the status bar)  Note: this extension supports both babel and v8 coverageProviders. However, please note the coverage might not be exactly the same, see facebook/jest#11188 for more details.  How to read coverage scheme and customize it In addition to the coverage summary that is shown on the top of the file, each line will be marked by its coverage status according to the coverage formatter configured. There are 3 types of coverage you might see in your source code, distinguished by colors:  \"covered\": if the code is covered. Either not marked or \"green\" by default, depends on the formatter. \"not-covered\": if the code is not covered. Marked as \"red\" by default. \"partially-covered\": Usually this mean the branch (such as if, switch statements) only partially tested. Marked as \"yellow\" by default. Please note, istanbuljs (the library jest used to generate coverage info) reports switch branch coverage with the first \"case\" statement instead of the \"switch\" statement. You can customize coverage start up behavior, style and colors, see customization for more details.  How to update and view snapshots snapshot-menu Users can update snapshots in any granularity from the context menu:  in the TestExplorer tree view: Update snapshot for the workspace, folder, test file, or just a single test. in the Editor's gutter menu: Update and view the snapshot for a test block. Snapshots are now fully supported for parameterized (test.each) and template-literal named tests.  How to use the extension with monorepo projects? The extension supports monorepo projects with the following mechanisms:  Single-root workspace: If all tests from monorepo packages can be run from a centralized location, such as project root, then a single-root workspace with proper \"jest.jestCommandLine\" and \"jest.rootPath\" setting should work. Multi-root workspace: If each monorepo package has its own local jest root and configuration, a multi-root workspaces is required. Users can use \"jest.disabledWorkspaceFolders\" to exclude the packages from jest run. Virtual folders: Starting from v6, users can also use virtual folders to configure monorepo packages from the root folder. See virtual folders for more details. For option 1 and 2, the easiest way to setup the monorepo projects is to use the Setup Tool and choose Setup monorepo project.  Please note, a working jest environment is a prerequisite for this extension. If you are having problem running the tests from a terminal, please follow jest instruction to set it up first.  How to read the StatusBar? StatusBar shows 2 types of information, illustrated below:  snapshot-menu Jest (folder-name): shows the mode and state of the \"active\" workspace folder or virtual folder (based on the active editor). As the hovering text showed, the \"active\" folder \"react-ts\" is in \"watch\" mode with coverage on. Jest-WS: shows the total test suite stats (pass, failed, unknown) for the whole workspace. Unknown test suites usually mean the test files are not yet run. Hovering over the status items will show tooltips with descriptions; clicking on the items open the corresponding output window.  How to perform Quick-Fix? Upon non-test errors, such as jest command not found, the extension can help user fix common errors with quick fix:  coverage-screen-shot cmd + click on the quick fix link in the output terminal will open a quick-fix chooser. A quick-fix chooser listed the fixes and hints to help resolve common errors: Customize Extensions: If you can run jest with CLI in the terminal but not with the extension, chances are you might need to configure the jest.jestCommandLine, jest.rootPath, monorepo settings, etc. This action will open the setup tools to continue. Defer or Change Run Mode: If the project has not yet ready to run jest, you can use this action to defer the test run or change the runMode to on-demand mode. This action brings up a runMode chooser to continue. Disable Extension: If you do not intend to run jest for this folder, you can choose this action to disable the extension. This action will set \"jest.enable\": false in the .vscode/settings.json file. Help: If you are not sure what to do, you can choose this action to open the troubleshooting page. How to see more debug info (self-diagnosis)? It is sometimes helpful to see the actual command and shell environment spawned, as well as internal debug messages, to diagnose issues:  Turn on the debug mode: set \"jest.debugMode\": true in .vscode/settings.json Open the developer console (via Help > Toggle Developer Tools menu), for example, to examine the PATH environment variables: look for the \"spawn\" log, expand the \"options\" object, expand the \"env\" property, all env variables (inherited from vscode process) should be there (view animation). Customization Settings Users can use the following settings to tailor the extension for their environments.  All settings are prefixed with jest and saved in standard .vscode/settings.json. settings marked with :x: are deprecated and subject to removal in the future. settings marked with 💼 apply to the whole workspace, otherwise on workspace-folder level. setting\tdescription\tdefault\texample/notes\tavailable Process\t\t\t\t jestCommandLine\tThe command line to start jest tests\tundefined\t\"jest.jestCommandLine\": \"npm test --\" or \"jest.jestCommandLine\": \"yarn test\" or \"jest.jestCommandLine\": \"node_modules/.bin/jest --config custom-config.js\"\t rootPath\tThe path to your frontend src folder\t\"\"\t\"jest.rootPath\":\"packages/app\" or \"jest.rootPath\":\"/apps/my-app\"\t nodeEnv\tAdd additional env variables to spawned jest process\tnull\t\"jest.nodeEnv\": {\"PORT\": \"9800\", \"BAR\":\"true\"}\t shell\tshell (path or LoginShell) for executing jest\tnull\t\"jest.shell\": \"/bin/bash\" or \"jest.shell\": \"powershell\" or \"jest.shell\": {\"path\": \"/bin/bash\"; args: [\"--login\"]}\t useDashedArgs\tDetermine if to use dashed arguments for jest processes\tundefined\t\"jest.useDashedArgs\":true\t>= v6.0.0 parserPluginOptions\tConfigure babel parser plugins\tnull\t\"jest.parserPluginOptions\": {decorators: 'legacy'}\t virtualFolders\tdefines multiple jest runs in a given vscode workspace folder\tundefined\t\"jest.virtualFolders\": \"[{\"name\": \"front-end\", \"rootPath': \"packages/front-end\"}, {\"name\": \"back-end\", \"rootPath': \"packages/back-end\"} ]\"\t>= v6.0.0 useJest30\tinstruct the extension to use jest 30 command line syntax\tundefined\t\"jest.useJest30\": true\t>= v6.3.0 UX\t\t\t\t outputConfig 💼\tControls test output experience across the whole workspace.\tundefined\t\"jest.outputConfig\": \"neutral\" or \"jest.outputConfig\": {\"revealOn\": \"run\", \"revealWithFocus\": \"terminal\", \"clearOnRun\": 'terminal\"\t>= v6.1.0 runMode\tControls most test UX, including when tests should be run, output management, etc\tundefined\t\"jest.runMode\": \"watch\" or \"jest.runMode\": \"on-demand\" or \"jest.runMode\": {\"type\": \"on-demand\", \"deferred\": true}\t>= v6.1.0 :x: autoClearTerminal\tClear the terminal output at the start of any new test run.\tfalse\t\"jest.autoClearTerminal\": true\tv6.0.0 (replaced by outputConfig) :x: testExplorer\tConfigure jest test explorer\tnull\t{\"showInlineError\": \"true\"}\t< 6.1.0 (replaced by runMode) :x: autoRun\tControls when and what tests should be run\tundefined\t\"jest.autoRun\": \"off\" or \"jest.autoRun\": \"watch\" or \"jest.autoRun\": {\"watch\": false, \"onSave\":\"test-only\"}\t< v6.1.0 (replaced by runMode) :x: autoRevealOutput\tDetermine when to show test output\t\"on-run\"\t\"jest.autoRevealOutput\": \"on-exec-error\"\t< v6.1.0 (replaced by outputConfig) Coverage\t\t\t\t :x: showCoverageOnLoad\tShow code coverage when extension starts\tfalse\t\"jest.showCoverageOnLoad\": true\t< v6.1.0 (replaced by runMode) coverageFormatter\tDetermine the coverage overlay style\t\"DefaultFormatter\"\t\"jest.coverageFormatter\": \"GutterFormatter\"\t coverageColors\tCoverage indicator color override\tundefined\t\"jest.coverageColors\": { \"uncovered\": \"rgba(255,99,71, 0.2)\", \"partially-covered\": \"rgba(255,215,0, 0.2)\"}\t Misc\t\t\t\t enable\tEnable/disable jest extension for the given workspace folder/virtual-folder\ttrue\t\"jest.enable\": false\t>=6.0.0 disabledWorkspaceFolders 💼\tDisabled workspace folders names in multi-root environment\t[]\t\"jest.disabledWorkspaceFolders\": [\"package-a\", \"package-b\"]\t debugMode\tEnable debug mode to diagnose plugin issues. (see developer console)\tfalse\t\"jest.debugMode\": true\t monitorLongRun\tmonitor long running tests based on given threshold in ms\t60000\t\"jest.monitorLongRun\": 120000\t jestCommandLine This should be the command users used to kick off the jest tests in the terminal. However, since the extension will append additional options at run time, please make sure the command line can pass along these options, which usually just means if you uses npm, add an additional \"--\" at the end (e.g. \"npm run test --\") if you haven't already in your script. It is recommended not to add the following options as they are managed by the extension: --watch, --watchAll, --coverage  rootPath If your project doesn't live in the root of your repository, you may want to customize the jest.rootPath setting to enlighten the extension as to where to look. For instance: \"jest.rootPath\": \"src/client-app\" will direct the extension to use the src/client-app folder as the root for Jest.  coverageFormatter There are 2 formatters to choose from:  DefaultFormatter: high light uncovered and partially-covered code inline as well as on the right overview ruler. (this is the default) GutterFormatter: render coverage status in the gutter as well as the overview ruler. (Note, there is an known issue in vscode (microsoft/vscode#5923) that gutter decorators could interfere with debug breakpoints visibility. Therefore, you probably want to disable coverage before debugging or switch to DefaultFormatter)  coverageColors Besides the formatter, user can also customize the color via jest.coverageColors to change color for 3 coverage categories: \"uncovered\", \"covered\", or \"partially-covered\",  example outputConfig The outputConfig controls the Jest output experience by specifying when and where to create, display, and clear the output content. It supports 2 output panels: TEST RESULTS and TERMINAL. The TEST RESULTS panel displays test results in the order they were run, while the TERMINAL panel organizes outputs by workspace folder. TERMINAL panel also contains the non-test run outputs, such as quick-fix link, extension auto-config info, and tips.  Type Definitions  // typescript type definition export interface JestRawOutputSetting {   revealOn?: 'run' | 'error' | 'demand';   revealWithFocus?: 'terminal' | 'test-results' | 'none';   clearOnRun?: 'both' | 'terminal' | 'test-results' | 'none'; } export type JestPredefinedOutputSetting = 'neutral' | 'terminal-based' | 'test-results-based'; export type JestOutputSetting = JestPredefinedOutputSetting | JestRawOutputSetting;  JestOutputSetting This setting can be one of the predefined types or a custom object.  Predefined OutputConfig Settings (JestPredefinedOutputSetting):  Predefined outputConfig\tDescription\tJestRawOutputSetting \"neutral\"\tA passive setting that does not favor either panel\t{revealOn: \"run\", revealWithFocus: \"none\", clearOnRun: \"none\"} \"terminal-based\"\tA terminal-centric output experience\t{revealOn: \"run\", revealWithFocus: \"terminal\", clearOnRun: \"none\"} \"test-results-based\"\tA test-results-centric output experience\t{revealOn: \"run\", revealWithFocus: \"test-results\", clearOnRun: \"none\"} Custom Config Object (JestRawOutputSetting):  revealOn: Create or make output window available (without automatic focus switch). Possible values: \"run\": On test starts. (default) \"error\": On test failure. \"demand\": On manual trigger. revealWithFocus: When revealing the output, which panel should have the focus, i.e. panel will become active. Possible values: \"terminal\": Show output in terminal panel and focus on it. \"test-results\": Show output in test results panel and focus on it. \"none\": No automatic focus change. (default) clearOnRun: Determine if to automatically clear the output before each test run. Possible values: \"both\": Clear both terminal and test results panel. \"terminal\": Clear the terminal panel only. \"test-results\": clear the test results panel only. \"none\": Do not clear any panel. (default) (Note: As of the current version, the testing framework does not support the clearing of the \"TEST RESULTS\" panel without side effects. The closest available command also clears all test item statuses, which may not be desirable. We are aware of this limitation and will raise the issue with the vscode team.) Handling Conflicts with \"TEST RESULTS\" panel setting  The Problem  The behavior of the \"TEST RESULTS\" panel is influenced by VSCode's native \"testing.automaticallyOpenTestResults\" setting. This can cause inconsistencies with your \"jest.outputConfig\" settings.  For instance, if you set \"jest.outputConfig\": {\"revealWithFocus\": \"none\"} to prevent automatic focus changes, but leave \"testing.automaticallyOpenTestResults\" at its default value of \"openOnTestStart\", the \"TEST RESULTS\" panel will still automatically switch focus when the tests are run via UI.  The Universal Solution  For a consistent Jest output experience, the simplest solution is to set \"testing.automaticallyOpenTestResults\": \"neverOpen\". This allows the extension to manage the \"TEST RESULTS\" and \"TERMINAL\" panels together using \"jest.outputConfig\" alone.  Further Customization  However, if you prefer \"TEST RESULTS\" and \"TERMINAL\" panels to behave differently and don't mind managing 2 settings yourself, you could play with different combinations.  For instance, if \"testing.automaticallyOpenTestResults\" is set to \"openOnTestFailure\", and you want your terminal panel to still reveal when any tests run, your setting would look like this: \"jest.outputConfig\": {revealWithFocus: \"terminal\"}.  Validation and Diagnosis  The extension features output config diagnosis information in the jest terminal, as well as the built-in conflict detection and quick fixes to assist with the transition.  Default Output Focus Behavior by RunMode When none of the output settings (\"testing.automaticallyOpenTestResults\" and \"jest.outputConfig\") are present, The default output behavior is determined by runMode:  runMode\tauto reveal \"TEST RESULTS\"\tauto reveal \"TERMINAL\" \"watch\"\t:heavy_multiplication_x:\t:heavy_multiplication_x: \"on-save\"\t:heavy_multiplication_x:\t:heavy_multiplication_x: \"on-demand\"\t:heavy_check_mark:\t:heavy_multiplication_x: Configuration Examples  Choose a passive output experience that is identical to the previous version: no automatic focus switch, no automatic clear. \"testing.automaticallyOpenTestResults\": \"neverOpen\", \"jest.outputConfig\": \"neutral\"  Choose a terminal-based experience and switch focus to it when test run starts. \"testing.automaticallyOpenTestResults\": \"neverOpen\", \"jest.outputConfig\": \"terminal-based\"  Choose a test-results-based experience and switch focus to it only when test fails. \"testing.automaticallyOpenTestResults\": \"neverOpen\", \"jest.outputConfig\": {   \"revealOn\": \"error\",   \"revealWithFocus\": \"test-results\", }  Clear the terminal output on each run but do not automatically switch focus to any panel. \"testing.automaticallyOpenTestResults\": \"neverOpen\", \"jest.outputConfig\": {   \"clearOnRun\": \"terminal\" }  [!NOTE] Migration Guide  Migrating to the new \"jest.outputConfig\" might require some manual adjustments, especially if you're working in a multi-root workspace. Here are some guidelines to help with the transition:  Workspace Level vs Workspace-Folder Level: The new \"jest.outputConfig\" is a workspace-level setting, unlike legacy settings like \"jest.autoClearTerminal\" and \"jest.autoRevealOutput\", which are workspace-folder level settings.  Backward Compatibility: If no \"jest.outputConfig\" is defined in your settings.json, the extension will attempt to generate a backward-compatible outputConfig in memory. This uses the \"testing.automaticallyOpenTestResults\" setting and any legacy settings (\"jest.autoClearTerminal\", \"jest.autoRevealOutput\") you might have. Note that this might only work for single-root workspaces.  Customization Steps: In general it should work out of the box, but if you encounter any issues, here are some steps to help adjusting the output behavior:  Use the \"Jest: Save Current Output Config\" command from the command palette to update your settings.json. Then adjust it to fit your needs. Fix warning if any: The save does not include \"testing.automaticallyOpenTestResults\", so you might see the conflict warning message. You can either use the \"Quick Fix\" action or adjust the settings.json manually (see handling conflict). Finally, remove any deprecated settings. testing.openTesting Migration: Note: As of December 2024, the testing.openTesting setting has been renamed to testing.automaticallyOpenTestResults in vscode. If you previously used testing.openTesting in your settings, vscode should have automatically updated it. If not, please update it manually to ensure the extension functions as expected. Following these steps will help you transition smoothly to using \"jest.outputConfig\".  runMode The runMode controls test UX, determining when tests should run, and housing the common run-time toggles like coverage.  Type Definitions  // typescript types interface JestRunModeOptions {   runAllTestsOnStartup?: boolean;   coverage?: boolean;   deferred?: boolean;   showInlineError?: boolean; } export type JestRunMode = JestRunModeOptions & (   | { type: 'watch' }   | { type: 'on-demand' }   | { type: 'on-save'; testFileOnly?: boolean } );  JestRunMode: Here's what each type does:  watch: Automatically triggers tests using watchman. on-demand: Manually run tests through the UI. on-save: Triggers tests every time you save a test or source file. JestRunModeOptions: Options applicable for all runMode types:  runAllTestsOnStartup: Want to run all tests as soon as the extension starts? Use this.  coverage: To get those coverage metrics, turn this on.  deferred: Usually, the extension sets things up before any test run, verifying the Jest env and discovering tests. This process is generally quick, but if you've got a hefty project or your setup isn't Jest-ready, this option helps:  true: Suspend the initial setup. Most UI components remain active. If you toggle runMode.deferred or manually trigger a test run, the setup will resume, deferred option will be set to false, and the runMode will operate as usual. false: Default behavior, the setup process gets going before any test run. defer vs. disable? 🤔 Predefined RunMode  The following are the predefined runMode configurations for convenience. They are mapped to the specified JestRunMode type at run time.  Predefined runMode\tDescription\tJestRunMode \"watch\"\trun tests by watchman\t{type: \"watch\"} \"on-save\"\trun tests when test or source files are saved\t{type: \"on-save\"} \"on-demand\"\trun tests on-demand through UI\t{type: \"on-demand\"} \"deferred\"\tdefer test run and discovery until the first on-demand run\t{type: \"on-demand\", deferred: true} Examples  Run jest with watch mode - the default runMode if none is specified. \"jest.runMode\": \"watch\"  Run jest tests via UI only. \"jest.runMode\": \"on-demand\"  Delay extension setup until the actual on-demand run. \"jest.runMode\": \"deferred\"  Run tests with coverage when test files are saved. \"jest.runMode\": {   \"type\": \"on-save\",   \"testFileOnly\": true,   \"coverage\": true }  Delay extension setup until the actual (on-demand) run; after that, automatically run tests when test/src files are saved. \"jest.runMode\": {   \"type\": \"on-save\",   \"deferred\": true }  runMode performance tradeoff  Balancing performance, convenience and completeness is often challenging. The runMode offers a tool to fine-tune this equilibrium according to your preferences.  runmode-tradeoff While the concepts of performance and automation are generally clear, \"completeness\" may require some elaboration:  Test coverage might not be comprehensive since it only captures the tests that were executed. If you modify the source or test code, potential failures in other tests may remain hidden until they are explicitly run. Tests bearing dynamic names, like those using test.each with variables or template literals, won't be translated. As a result, they must be executed through higher-level constructs, such as describe blocks with static names or entire test suites. [!NOTE] Migration Guide  Starting from v6.1.0, if no runMode is defined in settings.json, the extension will automatically generate one using legacy settings (autoRun, showCoverageOnLoad). To migrate, simply use the \"Jest: Save Current RunMode\" command from the command palette to update the setting, then remove the deprecated settings.  autoRun [!WARNING] As of v6.1.0, autoRun will be replaced by runMode. For transition details, please refer to the runMode migration.  AutoRun controls when tests should be executed automatically.  Performance and automation/completeness are often a trade-off. autoRun is the tool to fine-tune the balance, which is unique for every project and user.  autoRun-tradeoff Performance and automation are self-explanatory, \"completeness\" might not:  test coverage might not be complete as it only includes the tests that ran. when changing the source or test code, you might not see all the tests broken until you run them explicitly. tests with dynamic names (test.each with variables, template-literals, etc.) will not be translated; therefore, they can only be run through parent blocks (describe-with-static-name or test suite, etc.). There are 2 ways to change autoRun:  Temporarily toggle autoRun on/off in TestExplorer Change \"jest.autoRun\" in settings.json file. autoRun Configuration  AutoRun =   | \"watch\" | \"off\" | \"legacy\" | \"on-save\"   | { watch: true, onStartup?: [\"all-tests\"] }   | {       watch: false,       onStartup?: [\"all-tests\"],       onSave?: \"test-file\" | \"test-src-file\",     }  The string type are short-hand for the most common configurations:  Short Hand\tdescription\tactual config\tnote \"watch\"\trun jest in watch mode\t{\"watch\": true}\tthe default mode \"off\"\tturn off jest autoRun\t{\"watch\": false}\tthis is the manual mode \"legacy\"\tstarting a full test-run followed by jest watch\t{\"watch\": true, \"onStartup\": [\"all-tests\"]}\the default mode prior to v4.7 \"on-save\"\trun jest upon source or test file changes\t{\"watch\": false, \"onSave\": \"test-src-file\"}\t User can also pass the actual config in the .vscode/settings.json, see more example below.  example Please note, even when the autoRun is \"off\", the extension will still perform the usual setup upon start-up, such as checking jest env and parsing test blocks, so users can run test blocks manually. To turn off the extension completely for the given workspace, you can use jest.enable setting instead.  testExplorer [!WARNING] As of v6.1.0, this setting has been folded into runMode. For transition details, please refer to the runMode migration.  testExplorer = {showInlineError?: boolean}  showInlineError: (optional) show vscode style inline error and error message viewer. Default is false. shell shell = string | LoginShell;  interface LoginShell  {   path: string;   args: string[]; }  By default, jest command is executed in default shell ('cmd' for windows, '/bin/sh' for non-windows). Users can use the \"jest.shell\" setting to either pass the path of another shell (e.g. \"/bin/zsh\") or a LoginShell config, e.g. {\"path\": \"/bin/bash\", \"args\": [\"--login\"]})  Note the LoginShell is only applicable for non-windows platform and could cause a bit more overhead.  Auto recovery with login shell Since v5, if detected shell env issue, such as node: command not found or npm: no such file or directory, the extension will fallback to a login shell to ensure tests can run correctly. If will try to auto generate a login shell configuration based on the jest.shell setting, otherwise, it will use the default bash login-shell. Currently supported auto-fallback shells are bash, zsh, fish.  monitorLongRun monitorLongRun = number | 'off'  specify a number (milliseconds) means any run exceeds this threshold will trigger a warning. The number has to be > 0. specify \"off\" to disable long-run process monitoring Default is \"jest.monitorLongRun\":60000 (1 minute)  autoRevealOutput [!WARNING] As of v6.1.0, this setting has been folded into outputConfig. For transition details, please refer to the outputConfig migration.  autoRevealOutput = \"on-run\" | \"on-exec-error\" | \"off\"  on-run: reveal test run output when test run started. on-exec-error: reveal test run output only when execution error (note, not test error) occurred. off: no auto reveal test output. Note this could mask critical error, check status bar status for detail. parserPluginOptions parserPluginOptions = { decorators?:    | 'legacy'    | {       decoratorsBeforeExport?: boolean;       allowCallParenthesized?: boolean;     }   }  This extension uses babel to parse the test files. For decorators plugin options, it uses 'decorators', {decoratorsBeforeExport: true} by default, which can be customized with this setting. Examples:  \"jest.parserPluginOptions\": {\"decorators\": \"legacy\"}  \"jest.parserPluginOptions\": {\"decorators\": {\"decoratorsBeforeExport\": false}}   virtualFolders Much like a vscode workspace folder, which manages a runtime environment for a specific folder, a virtualFolder manages a custom Jest runtime environment. Each virtualFolder can have its own resource-level settings, such as jestCommandLine and rootPath.  You can configure multiple virtual folders within any given vscode workspace folder using the jest.virtualFolders setting. Here are a few common use cases and examples:  Your project contains multiple jest configurations, such as unit test and integration test. While they run on the same set of source files, you want to run them separately and with different frequency: for instance, unit tests should always run automatically (\"runMode\": \"watch\") while the integration tests should only run on-demand (\"runMode\": \"on-demand\"):  // settings.json for unit and integration test environments under the root folder: {   \"jest.virtualFolders\": [     {\"name\": \"unit-tests\", \"jestCommandLine\": \"yarn test --config jest.unit.config.js\", \"runMode\": \"watch\"},     {\"name\": \"integration-tests\", \"jestCommandLine\": \"yarn test --config jest.integration.config.js\", \"runMode\": \"on-demand\"}   ] }  Your project is a monorepo and you want to run tests for each package separately. You can configure a virtual folder for each package:  // settings.json for a monorepo project under the root folder: {   \"jest.virtualFolders\": [     {\"name\": \"package1\", \"rootPath\": \"packages/package1\"},     {\"name\": \"package2\", \"rootPath\": \"packages/package2\"}   ] }  Virtual Folders Inherit and Override Workspace Folder Settings Virtual folders inherit settings from the parent workspace but can override these settings as needed. For instance, you can set the runMode to \"watch\" in the workspace, but set it to \"on-demand\" for the virtual folders with many or expensive tests. This flexibility allows for granular control over the testing environments within a single workspace folder.  // settings.json in the \"project\" folder {   ...   \"jest.runMode\": \"watch\",   \"jest.jestCommandLine\": \"yarn test\",   \"jest.virtualFolders\": [     {\"name\": \"unit-tests\"},     {\"name\": \"integration-tests\", , \"runMode\": \"on-demand\", \"jestCommandLine\": \"yarn test --config=jest.integration.config.js\"}   ] }  In this scenario, the \"project\" workspace will not run its own Jest environment but will instead spawn two separate Jest environments for \"unit-tests\" and \"integration-tests\".  🤔 VirtualFolders vs. Multi-root Workspace? Debug Config This extension looks for jest specific debug config (\"vscode-jest-tests.[folder-name]\" or \"vscode-jest-tests.v2.[folder-name]\") in the following order:  workspace folder .vscode/launch.json. workspace xxx.code-workspace, if exists if none found, generated a debug config The generated config should work for most standard jest or projects bootstrapped by create-react-app, however it might fall short for more sophisticated projects. Please use the setup tool to help you configure or edit the launch.json file manually.  There are many information online about how to setup vscode debug config for specific environments/frameworks, you might find the following helpful:  vscode debug config properties Launch configurations for common scenarios vscode-recipes for debug jest tests Debug Config v2 v4.3 introduces a \"variable substitution\" based config with name \"vscode-jest-tests.v2.[folder-name]\". The extension will merely substitute the jest variables in the config, without adding/removing anything else.  Currently supported variables:  ${jest.testNamePattern} - will be replaced by the test block's full name (include the surrounding describe block names). ${jest.testFile} - will be replaced by the test file name. ${jest.testFilePattern} - will be replaced by the test file name suitable for regex arguments such as --testPathPattern. Examples Commands This extension contributes the following commands and can be accessed via Command Palette:  command\tdescription\tavailability Jest: Start All Runners\tstart or restart all jest runners\talways Jest: Stop All Runners\tstop all jest runners\talways Jest: Toggle Coverage\ttoggle coverage mode for all runners\talways Jest: Start Runner (Select Workspace)\tstart or restart the jest runner for the selected workspace\tmulti-root workspace Jest: Stop Runner (Select Workspace)\tstop jest runner for the selected workspace\tmulti-root workspace Jest: Toggle Coverage (Select Workspace)\ttoggle coverage mode for the selected workspace\tmulti-root workspace Jest: Run All Tests\trun all tests for all the workspaces\talways Jest: Run All Tests (Select Workspace)\trun all tests for the selected workspace\tmulti-root workspace Jest: Run All Tests in Current Workspace\trun all tests for the current workspace based on the active editor\talways Jest: Toggle Coverage for Current Workspace\ttoggle coverage mode for the current workspace based on the active editor\talways Jest: Save Current RunMode\tupdate \"jest.runMode\" in settings.json based on the current value\talways (>= 6.1.0) Jest: Save Current Output Config\tupdate \"jest.outputConfig\" in settings.json based on the current value\talways (>= 6.1.0) Jest: Setup Extension\tstart the setup tool\talways In addition, TestExplorer also exposed many handy commands, see the full list by searching for testing in vscode keyboard shortcuts editor. One can assign/change keyboard shortcut to any of these commands, see vscode Key Bindings for more details.  Menu User can trigger the following action from the text editor context-menu  menu\tdescription\tkeyboard shortcut Jest: Run Related Tests\tif in test file, run all tests in the file; if in source file, run all tests with dependency to the file\tCtrl-Option-t (Mac) or Ctrl-Alt-t Please see vscode Key Bindings if you want to change the keyboard shortcut.  Troubleshooting Sorry you are having trouble with the extension. If your issue did not get resolved after checking out the how-to section and the tips below, feel free to ask the community, chances are some one else had a similar experience and could help resolving it.  Jest failed to run If you can't run jest in the terminal, please reference jest configuration to setup accordingly.  If you can run jest manually in the terminal but the extension showed error like \"xxx ended unexpectedly\", following are the most common causes (see self-diagnosis if you need more debug info):  jest command line issue: such as you usually run yarn test but the extension uses the default jest instead. Try configuring the jest.jestCommandLine to mimic how you run jest from the terminal, such as yarn test or npm run test --. The extension can auto-config common configurations like create react apps but not custom scripts like CRACO. root path issue: When jest test root path is different from the workspace folder. You can set jest.rootPath to the actual jest root. monorepo project issue: you have a monorepo project but might not have been set up properly. Please reference how to use the extension with monorepo projects. Feel free to try the quick-fix chooser, or check out the customization section to manually adjust the extension.  A few known failure scenarios:  PNP without node_modules nor a \"test\" script in package.json will need to set up jest.jestCommandLine explicitly. Performance issue? The extension should be a thin wrapper on top of the jest process, i.e., it shouldn't use much more resources than the jest process itself.  Having said that, we have definitely seen sluggish performance for some projects/users. The short answer is try changing runMode in the explorer, which should usually show noticeable improvement.  The long answer is a bit more complicated:  The jest/node/watchman might be slow due to code changes, your test setup, environment, etc. See facebook/jest#11956 for a glimpse of such examples. However, this issue should impact with or without this extension. There are many resources and tips online about optimizing jest performance; we will leave it at that. Depending on the degree of cross-dependency or your development habit (e.g., save frequently even before the code is complete), the runMode system ( \"watch\" or \"on-save\") might decide to run many more tests than you intended to. Imagine adding a single test could trigger 90% of all the tests in the project... yeah we have been there, and it's not fun. If that's you, try changing runMode to \"on-demand\" and only trigger test-run when ready with the run button in the gutter or test tree. But keep in mind while performance is important, turning runMode to be less \"complete\" does come with a cost, such as incomplete coverage and missing-broken-tests-detection. Please read up on the runMode trade-off and experiment to find the one that works for you. Never say never; it is possible that we did something stupid. :cold_sweat: Feel free to log an issue if your performance awe still needs to be resolved after you patiently read and tried the above. Intermittent errors for (npm/yarn/node) command not found during test run or debugging This should only happen in Linux or MacOS, and is due to vscode not able to fully initialize the shell env when it starts up (more details here).  for test run: A solution is introduced in v5.0.2, which will automatically recover with a login-shell during such situation. Hopefully, this should not be an issue any more 🤞. for test debugging: you can instruct vscode debugger to use a login shell via task/debug profile, for example, adding the following in your user's settings then restart:  \"terminal.integrated.automationProfile.osx\": {   \"args\": [\"-l\"],   \"path\": \"/bin/bash\" },  Alternatively, you can try the following methods if you prefer a non-login-shell solution:  simply restart vscode sometimes can fix it start vscode from a terminal: type code from your external terminal I don't see \"Jest\" in the bottom status bar This means the extension is not activated.  vscode will automatically activate the extension upon detecting any of the following patterns:  jest config file (jest.json, jest.config.js, jest.config.ts, jest.config.mjs, jest.config.cjs, jest.config.json) any where under the project root. jest command (node_modules/.bin/jest, node_modules/react-scripts/node_modules/.bin/jest) or react-native script (node_modules/react-native-scripts) under the project root. If none of the auto activation criteria is met, you can do the following to manually activate the extension:  create an empty .vscode-jest file at your actual project root. start jest run via command palette: \"Jest: Start All Runners\" will also activate the extension for the current vscode process. What to do with \"Long Running Tests Warning\" The extension monitor excessive test run with \"jest.monitorLongRun\" setting. By default if any runs exceed 60 seconds, a warning message will be shown.  If running the tests with the extension seems to be longer than running it from a terminal, chances are you can use \"jest.runMode\" to optimize it, for example:  for process type \"all-tests\", you can turn off the all-tests from runMode. for process type \"watch-tests\" or \"watch-all-tests\", you can maybe turn off watch mode and use \"on-save\" or \"on-demand\" instead. If the tests are slow even from the terminal, i.e. without the extension, you will need to optimize your tests, feel free to check out jest troubleshooting or other online articles.  If the run appeared to hang, i.e. the TestExplorer or statusBar showed test running when it is not. It might be related to this jest issue, which should be fixed after release 29.0.2. If you believe your issue is different, please file a new issue so we can take a look.  You can also turn off the monitor or change the threshold with \"jest.monitorLongRun\" to meet your needs.  The tests and status do not match or some tests showing question marks unexpectedly? If your test file happen to have parameterized tests, i.e. test.each variations, please make sure you have jest version >= 26.5.  If the above did not resolve your issue, please see the self-diagnosis to show more insight of why the test and result could not be matched.  Want to Contribute? Thanks for considering! Check here for useful tips and guidelines.  License vscode-jest is MIT licensed.",
    "ctk.ruleSet": [
        {
            "id": 1,
            "key": "OAuth Quickstart"
        },
        {
            "id": 2,
            "key": "Sample OAuth Application README"
        },
        {
            "id": 3,
            "key": "Netlify API Documentation"
        },
        {
            "id": 4,
            "key": "OAuth Quickstart API"
        },
        {
            "id": 5,
            "key": "OAuth Application Settings"
        },
        {
            "id": 6,
            "key": "Javascript OAuth Quickstart"
        },
        {
            "id": 7,
            "key": "OAuth Calling an API"
        },
        {
            "id": 8,
            "key": "Redirect Users"
        },
        {
            "id": 9,
            "key": "Auth0 Actions"
        },
        {
            "id": 10,
            "key": "Oauth Login Trigger"
        },
        {
            "id": 11,
            "key": "Jest Documentation"
        }
    ]
}



