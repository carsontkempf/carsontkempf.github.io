{
    "files.exclude": {
        "**/__pycache__": true,
        "**/*.pyc": true,
        "_sass/_fonts.css": true,
        "_sass/_fonts.css.map": true,
        "_sass/_fonts.scss": true,
        "_sass/_jekyll-theme-minimal.css": true,
        "_sass/_jekyll-theme-minimal.css.map": true,
        "_sass/_minimal.css": true,
        "_sass/_minimal.css.map": true,
        "_sass/_minimal.scss": true,
        "_sass/_rouge-github.css": true,
        "_sass/_rouge-github.css.map": true,
        "_sass/_rouge-github.scss": true,
        "_site": true,
        ".github/workflows": true,
        ".idea": true,
        "404.html": true,
        "Gemfile": true,
        "Gemfile.lock": true,
        ".github": true,
        ".vscode": true,
        ".gitignore": true,
        "node_modules": true,
        "package-lock.json": true,
        "assets/css": true,
        "assets/fonts": true,
        "assets/img": true,
        "assets/js/scale.fix.js": true,
        "netlify.toml": true,
        ".ruby-version": true
    },


/* Gemini Code Assist doesn't have a maximum text input  */


    "geminicodeassist.rules": "OAuth Quickstart: Add Login to Your JavaScript Application Auth0 allows you to add authentication to almost any application type quickly. This guide demonstrates how to integrate Auth0, add authentication, and display user profile information in a Single-Page Application (SPA) that uses plain JavaScript, using the Auth0 SPA SDK.  To use this quickstart, you’ll need to:  Sign up for a free Auth0 account or log in to Auth0.  Have a working project that you want to integrate with. Alternatively, you can view or download a sample application after logging in.  This quickstart assumes you are adding Auth0 to a plain JavaScript application, as opposed to using a framework such as React or Angular.  1 Configure Auth0 To use Auth0 services, you’ll need to have an application set up in the Auth0 Dashboard. The Auth0 application is where you will configure how you want authentication to work for the project you are developing.  Configure an application Use the interactive selector to create a new Auth0 application or select an existing application that represents the project you want to integrate with. Every application in Auth0 is assigned an alphanumeric, unique client ID that your application code will use to call Auth0 APIs through the SDK.  Any settings you configure using this quickstart will automatically update for your Application in the Dashboard, which is where you can manage your Applications in the future.  If you would rather explore a complete configuration, you can view a sample application instead.  Configure Callback URLs A callback URL is a URL in your application that you would like Auth0 to redirect users to after they have authenticated. If not set, users will not be returned to your application after they log in.  If you are following along with our sample project, set this to http://localhost:3000.  Configure Logout URLs A logout URL is a URL in your application that you would like Auth0 to redirect users to after they have logged out. If not set, users will not be able to log out from your application and will receive an error.  If you are following along with our sample project, set this to http://localhost:3000.  Configure Allowed Web Origins An Allowed Web Origin is a URL that you want to be allowed to access to your authentication flow. This must contain the URL of your project. If not properly set, your project will be unable to silently refresh authentication tokens, so your users will be logged out the next time they visit your application or refresh a page.  If you are following along with our sample project, set this to http://localhost:3000.  2 Add the Auth0 SPA SDK Auth0 provides a SPA SDK (auth0-spa-js) to simplify the process of implementing Auth0 authentication and authorization in JavaScript applications. You can install the Auth0 SPA SDK as an NPM package or from the CDN. For the purpose of this quickstart, we will use the CDN. Include this script tag on your HTML page:  <script src=\"https://cdn.auth0.com/js/auth0-spa-js/2.0/auth0-spa-js.production.js\"></script> Was this helpful?  / 3 Create the Auth0 client Create a new instance of the Auth0 client provided by the Auth0 SPA SDK and provide the Auth0 application details you created earlier in this quickstart.  If a user has previously logged in, the client will refresh the authentication state on page load; the user will still be logged in once the page is refreshed.  4 Add login to your application Now that you have configured your Auth0 Application, added the Auth0 SPA SDK, and created the Auth0 client, you need to set up login for your project. To do this, you will use the SDK’s loginWithRedirect() method to redirect users to the Auth0 Universal Login page where Auth0 can authenticate them. After a user successfully authenticates, they will be redirected to the callback URL you set up earlier in this quickstart.  Create a login button in your application that calls loginWithRedirect() when selected.  Checkpoint You should now be able to log in to your application.  Run your application, and select the login button. Verify that:  you can log in or sign up using a username and password  your application redirects you to the Auth0 Universal Login page  you are redirected to Auth0 for authentication  Auth0 successfully redirects back to your application after authentication  you do not receive any errors in the console related to Auth0  5 Handle the callback from Auth0 When the browser is redirected back to your application process, your application should call the handleRedirectCallback() function on the Auth0 client only when it detects a callback from Auth0. One way to do this is to only call handleRedirectCallback() when code and state query parameters are detected.  If handling the callback was successful, the parameters should be removed from the URL so the callback handler will not be triggered the next time the page loads.  Checkpoint Your callback from Auth0 should now be properly handled.  Run your application, and select the login button again. Verify that:  Auth0 successfully redirects back to your application after authentication.  the query parameters are removed from the URL.  6 Add logout to your application Users who log in to your project will also need a way to log out. The Auth0 client provides a logout() method that you can use to log a user out of your app. When users log out, they will be redirected to your Auth0 logout endpoint, which will then immediately redirect them to your application and the logout URL you set up earlier in this quickstart.  Create a logout button in your application that calls logout() when selected.  The SDK exposes an isAuthenticated() function that allows you to check whether a user is authenticated or not. You can render the login and logout buttons conditionally based on the value of the isAuthenticated() function. Alternatively, you can use a single button to combine both login and logout buttons as well as their conditional rendering.  Checkpoint  You should now be able to log out of your application.  Run your application, log in, and select the logout button. Verify that:  you are redirected to Auth0's logout endpoint.  Auth0 successfully redirects back to your application and the correct logout URL.  you are no longer logged in to your application.  you do not receive any errors in the console related to Auth0.  7 Show user profile information Now that your users can log in and log out, you will likely want to be able to retrieve the profile information associated with authenticated users. For example, you may want to be able to personalize the user interface by displaying a logged-in user’s name or profile picture.  The Auth0 SPA SDK provides user information through the getUser() function exposed by the Auth0 client. The Auth0 client also exposes an isAuthenticated() function that allows you to check whether a user is authenticated or not, which you can use to determine whether to show or hide UI elements, for example. Review the code in the interactive panel to see examples of how to use these functions.  Checkpoint You should now be able to view user profile information.  Run your application, and verify that:  user information displays correctly after you have logged in.  user information does not display after you have logged out.\n\n\n\nSample OAuth Application README: # Sample 01 - Login  The purpose of this article is to demonstrate how simple it is to set up and use the new Single Page Application SDK, and authenticate a user in your application using Auth0's Universal Login Page.  ## Running the Sample Application  The sample can be run locally, by cloning the repository to your machine and then following the steps below.  ### Specifying Auth0 Credentials  To specify the application client ID and domain, make a copy of `auth_config.json.example` and rename it to `auth_config.json`. Then open it in a text editor and supply the values for your application:  ```json {   \"domain\": \"{DOMAIN}\",   \"clientId\": \"{CLIENT_ID}\" } ```  ### Installation  After cloning the repository, run:  ```bash $ npm install ```  This will install all of the necessary packages in order for the sample to run.  ### Running the Application  This version of the application uses an [Express](https://expressjs.com) server that can serve the site from a single page. To start the app from the terminal, run:  ```bash $ npm run dev ```  ## Frequently Asked Questions  We are compiling a list of questions and answers regarding the new JavaScript SDK - if you're having issues running the sample applications, [check the FAQ](https://github.com/auth0/auth0-spa-js/blob/master/FAQ.md)!  ## What is Auth0?  Auth0 helps you to:  - Add authentication with [multiple authentication sources](https://docs.auth0.com/identityproviders), either social like **Google, Facebook, Microsoft Account, LinkedIn, GitHub, Twitter, Box, Salesforce, among others**, or enterprise identity systems like **Windows Azure AD, Google Apps, Active Directory, ADFS or any SAML Identity Provider**. - Add authentication through more traditional **[username/password databases](https://docs.auth0.com/mysql-connection-tutorial)**. - Add support for **[linking different user accounts](https://docs.auth0.com/link-accounts)** with the same user. - Support for generating signed [Json Web Tokens](https://docs.auth0.com/jwt) to call your APIs and **flow the user identity** securely. - Analytics of how, when and where users are logging in. - Pull data from other sources and add it to the user profile, through [JavaScript rules](https://docs.auth0.com/rules).  ## Create a free Auth0 account  1. Go to [Auth0](https://auth0.com/signup) and click Sign Up. 2. Use Google, GitHub or Microsoft Account to login.  ## Issue Reporting  If you have found a bug or if you have a feature request, please report them at this repository issues section. Please do not report security vulnerabilities on the public GitHub issue tracker. The [Responsible Disclosure Program](https://auth0.com/whitehat) details the procedure for disclosing security issues.  ## Author  [Auth0](auth0.com)  ## License  This project is licensed under the MIT license. See the [LICENSE](LICENSE.txt) file for more info.\n\n\n\nNetlify API Documentation: Get started with the Netlify API Use the Netlify REST API to manage atomic deploys of your sites and apps, manage form submissions, inject JavaScript snippets, manage DNS, and so much more.   This document covers the basics for interacting with the Netlify API, plus instructions for deploying sites and notes on some commonly used endpoints.  You can browse the OpenAPI reference for the Netlify API to explore available endpoints. Visit our Forums for more tips and conversation about understanding and using Netlify’s API.  Additionally, we have two API clients for your convenience:  Go Client JS Client If you’d like to interact with the Netlify API using a no-code tool, you can use n8n.io’s Netlify node. The node currently supports the following operations:  Create a new deployment Get a deployment Get all deployments Cancel a deployment Get a site Get all sites Delete a site #Make a request All URLs start with https://api.netlify.com/api/v1/. SSL only. The path is prefixed with the API version. If we change the API in backward-incompatible ways, we’ll bump the version marker and maintain stable support for the old URLs.  To make a request for all sites you have access to, for example, append the sites index path to the base URL to form something like https://api.netlify.com/api/v1/sites. Here’s an example in curl:  curl -H \"User-Agent: MyApp (YOUR_NAME@EXAMPLE.COM)\" \\      -H \"Authorization: Bearer YOUR_OAUTH2_ACCESS_TOKEN\" \\      https://api.netlify.com/api/v1/sites  #Authentication Netlify uses OAuth2 for authentication. All requests must use HTTPS.  To generate a personal access token (PAT):  Go to Applications > Personal access tokens. Select New access token. Enter a descriptive name to help you remember what the token will be used for. Select Allow access to my SAML-based Netlify team to authorize access to your SAML-based team data through the API. Select an Expiration date for your token to help keep your information secure. Select Generate token. Copy the token to your clipboard and store it in a safe location. Once you navigate away from this page, you won’t be able to access the value again. Select Done. Use your PAT for manual authentication in shell scripts or commands that use the Netlify API.  To authenticate API requests, include the token in the authorization header:  Authorization: Bearer <YOUR_PERSONAL_ACCESS_TOKEN>  To authenticate in shell scripts, refer to the code sample above for an example of how to use this token in a curl request.  SAML SSO  If your team requires you to log in with single sign-on (SSO), your personal access tokens will be denied access to the team by default. You can choose to grant access to the team when you generate a new token. You must be logged in to the team with SSO to grant access to it.  If you’re making a public integration with Netlify for others to enjoy, you must use OAuth2. This allows users to authorize your application to use Netlify on their behalf without having to copy/paste API tokens or touch sensitive login info. You’ll need an application client key and a client secret to integrate with the Netlify API. You can register a new application in your Netlify user settings for OAuth applications. Visit our blog post on integrating with Netlify for more information including common grant types and an example project.  The OAuth2 end-user authorization endpoint is https://app.netlify.com/authorize.  #Rate limiting To protect Netlify from getting flooded by automated deploys or misbehaving applications, the Netlify API is rate limited.  You can make up to 500 requests per minute for most requests. Certain operations have their own stricter limits. For example, you can deploy through the Netlify API up to 3 times per minute and up to 100 times per day.  You can check the returned HTTP headers of any API request to verify your current rate limit status:  X-RateLimit-Limit: 500 X-RateLimit-Remaining: 56 X-RateLimit-Reset: 1372700873  If you need higher limits, please contact us.  #Pagination All API requests that return over 100 items are paginated by default, with a limit of 100 items per page. You can specify further pages with the ?page parameter. You can also set a custom page size that’s less than 100 with the ?per_page parameter.  Note that page numbering starts with 1 and that omitting the ?page parameter will return the first page.  #Link header The pagination info is included in the Link header.  Link: <https://api.netlify.com/api/v1/sites?page=3&per_page=20>; rel=\"next\",     <https://api.netlify.com/api/v1/sites?page=5&per_page=20>; rel=\"last\"  Linebreak is included for readability.  The possible rel values are:  next Shows the URL of the immediate next page of results. last Shows the URL of the last page of results. prev Shows the URL of the immediate previous page of results. #Deploy with the API The most common API action is doing deploys, either of a new site or an existing site. If builds are stopped for an existing site, you can still deploy with the API to update the site.  Netlify supports two ways of doing deploys:  Sending a digest of all files in your deploy, and then uploading any files Netlify doesn’t already have on its storage servers. Sending a ZIP file of the entire site and letting Netlify unzip and deploy. We generally recommend the first way, since it’s more efficient.  Whether you deploy a brand new site or create a deploy within an existing site, the process is similar.  First create a new site, if needed:  POST /api/v1/sites  Now you have a site ID and you can create a new deploy, either with a file digest or a ZIP file.  #File digest method We recommend using a digest including a file path and SHA1 for each item. This method also allows you to upload serverless functions, however serverless functions should use SHA256 instead.  POST /api/v1/sites/{site_id}/deploys  {   \"files\": {     \"/index.html\": \"907d14fb3af2b0d4f18c2d46abe8aedce17367bd\",     \"/main.css\": \"f18c2d7367bd9046abe8aedce17d14fb3af2b0d4\"   },   \"functions\": {     \"hello-world\": \"708b029d8aa9c8fa513d1a25b97ffb6efb12b423\"   } }  When using a file digest, the API will return an object which includes the following properties:  {   \"id\": \"1234\",   \"required\": [\"907d14fb3af2b0d4f18c2d46abe8aedce17367bd\"],   \"required_functions\": [\"708b029d8aa9c8fa513d1a25b97ffb6efb12b423\"] }  The required property will give you a list of files by SHA1 that you need to upload. Similarly, required_functions will get you an array of required functions by SHA256 to upload, if you included a functions digest when creating the deploy.  Tip  If you have two files with the same SHA1, you don’t have to upload both of them.  Now upload the files, using the deploy ID returned as id in the file digest response:  PUT /api/v1/deploys/{deploy_id}/files/index.html  Warning  Be sure to escape the file_path parameter, and ensure file paths don’t include # or ? characters.  Use Content-Type: application/octet-stream and use the file contents as the HTTP request body.  If the required file is a function, upload it to the functions endpoint, again using the deploy ID returned as id in the file digest response:  PUT /api/v1/deploys/{deploy_id}/functions/hello-world?runtime=js  Possible runtime parameters are:  js: zipped Node.js programs or bundled JavaScript files go: Go binaries When uploading functions, use the name of the function, not the file path or any file extensions. Clients must zip the function prior to uploading to the API.  Once all files have been uploaded, Netlify will post process the deploy and invalidate the CDN.  #Async requests for large deploys API requests that last longer than 30 seconds will be terminated automatically. When creating large deploys, pass the async property in your file digest:  {   \"async\": true,   \"files\": {     \"/index.html\": \"907d14fb3af2b0d4f18c2d46abe8aedce17367bd\"   },   \"functions\": {     \"hello-world\": \"708b029d8aa9c8fa513d1a25b97ffb6efb12b423\"   } }  The request will then return the deploy ID (as id) which can be polled to determine when the deploy is ready for file uploads.  GET /api/v1/sites/{site_id}/deploys/{deploy_id}  You can check the state parameter in the response. It will be set to preparing as the upload manifest is generated, and either prepared, uploading, uploaded, or ready depending on the contents of the deploy. At this point, the deploy is either ready, or the API will give you a list of required files and required_functions.  Additionally, when uploading large files, sometimes the request will time out. It is safe to retry these uploads a few times to verify whether additional attempts are successful.  #ZIP file method You can deploy using a ZIP file but note there’s a limit of 25,000 files per zip extraction for a site. For the same site, you always need to upload a single zip with all the files.  To deploy using a ZIP file, create a new deploy with Content-Type: application/zip and the ZIP file as the HTTP request body:  POST /api/v1/sites/{site_id}/deploys  A deploy from a ZIP file will enter post-processing mode straight after being created.  While we generally recommend using file digests, you can use the ZIP file method straight from the command line with cURL:  curl -H \"Content-Type: application/zip\" \\      -H \"Authorization: Bearer YOUR_OAUTH2_ACCESS_TOKEN\" \\      --data-binary \"@website.zip\" \\      https://api.netlify.com/api/v1/sites/mysite.netlify.app/deploys  #Create and deploy at once When creating a new site, you can include a file digest or a ZIP file straight away, to save an HTTP request.  The following will create a new site and deploy it from a ZIP file:  curl -H \"Content-Type: application/zip\" \\      -H \"Authorization: Bearer YOUR_OAUTH2_ACCESS_TOKEN\" \\      --data-binary \"@website.zip\" \\      https://api.netlify.com/api/v1/sites  #Poll for deploy state You can poll the deploy to check the state:  GET /api/v1/deploys/{deploy_id}  { \"id\": \"1234\", \"state\": \"ready\" }  Once the state changes to ready, the deploy is live.  #Draft deploys When creating a new deploy, you can set \"draft\": true to mark the deploy as a draft deploy.  A draft deploy works like a normal deploy, but it won’t change the current published deploy of the site when it’s done processing.  #Commonly used endpoints This section describes usage for some popular endpoints.  We also have an OpenAPI reference for the Netlify API that you can explore.  Visit our Forums for more tips and conversation about understanding and using Netlify’s API.  #Sites The /sites endpoint allows you to access sites deployed on Netlify.  Trying to manage your site’s environment variables?  To update or retrieve your site’s environment variables, leverage the environment variables endpoints. The /sites endpoint does not support environment variables.  #Get sites GET /api/v1/sites returns all sites you have access to.  [   {     \"id\": \"3970e0fe-8564-4903-9a55-c5f8de49fb8b\",     \"premium\": false,     \"claimed\": true,     \"name\": \"synergy\",     \"custom_domain\": \"www.example.com\",     \"url\": \"http://www.example.com\",     \"admin_url\": \"https://api.netlify.com/sites/synergy\",     \"screenshot_url\": null,     \"created_at\": \"2013-09-17T05:13:08Z\",     \"updated_at\": \"2013-09-17T05:13:19Z\",     \"user_id\": \"51f60d2d5803545326000005\"   } ]  #Get site GET /api/v1/sites/{site_id} returns the specified site.  About site IDs  You can find a value for {site_id} by visiting the Netlify UI at Project configuration > General > Project details > Project information. Project IDs (formerly called site IDs) are also available in the response when you create a site or get a list of sites. Whenever the API requires a {site_id}, you can either use the id of a site obtained through the API, or the domain of the site (for example, mysite.netlify.app or www.example.com). These two are interchangeable whenever they’re used in API paths. GET /api/v1/sites/3970e0fe-8564-4903-9a55-c5f8de49fb8b returns the site with a matching id.  GET /api/v1/sites/www.example.com returns the site matching the domain www.example.com.  {   \"id\": \"3970e0fe-8564-4903-9a55-c5f8de49fb8b\",   \"premium\": false,   \"claimed\": true,   \"name\": \"synergy\",   \"custom_domain\": \"www.example.com\",   \"notification_email\": \"me@example.com\",   \"url\": \"http://www.example.com\",   \"admin_url\": \"https://api.netlify.com/sites/synergy\",   \"screenshot_url\": null,   \"created_at\": \"2013-09-17T05:13:08Z\",   \"updated_at\": \"2013-09-17T05:13:19Z\",   \"user_id\": \"51f60d2d5803545326000005\" }  #Create site POST /api/v1/sites creates a new site. By default the site will be created in your personal team.  When creating a site, you can set the following properties:  name: the name of the site (mysite.netlify.app) custom_domain: the custom domain of the site (www.example.com) password: password protect the site force_ssl: will force SSL on the site if SSL is enabled processing_settings: sets the Pretty URLs post processing setting: {   \"html\": { \"pretty_urls\": true } }  repo: configures continuous deployment. It’s a bit complicated to create a repo object so please visit our Forums for a verified Support Guide on linking a repository using the API. #Create site in team POST /api/v1/{account_slug}/sites/ creates a new site in a specific team. It takes the same parameters as when creating a site.  #Update site PATCH /api/v1/sites/{site_id} updates some attributes on a site.  PUT /api/v1/sites/{site_id} updates some attributes on a site.  This lets you update a site. It takes all the same parameters as when creating a site.  If you do a PUT request to a site with Content-Type: application/zip and a zipped website in the HTTP request body, it works exactly like creating a new deploy for the site based on a ZIP file.  #Provision SSL for a site POST /api/v1/sites/{site_id}/ssl activates SSL for a site.  The site must have a custom domain with DNS records configured to point to Netlify’s infrastructure.  Any domain aliases with valid DNS records will also be included in the SSL certificate for the site.  This endpoint manually triggers SSL provisioning for a site’s custom domains. Once SSL provisioning is successful, the domain will be served over HTTPS.  #Delete site DELETE /api/v1/sites/{site_id} permanently deletes a site.  This will return 200 OK.  #Site metadata Each site has a metadata object. The properties of the metadata object can be used within the snippets for a site by using the Liquid template syntax.  #Get metadata GET /api/v1/sites/{site_id}/metadata gets the metadata for a site.  {   \"my_meta_key\": \"my_meta_value\" }  #Update metadata PUT /api/v1/sites/{site_id}/metadata replaces the metadata object with a new metadata object.  #Environment variables The environment variables API endpoints allow you to access and set both site and shared environment variables. Environment variable changes require a build and deploy to take effect.  #Get environment variables GET /api/v1/accounts/{account_id}/env returns all environment variables for a team or site. The list will only include shared environment variables if the request is made by a Team Owner.  GET /api/v1/accounts/{account_id}/env/{key} returns an individual environment variable for a team or site.  About account IDs  You can find a value for {account_id} by querying GET /api/v1/accounts/{account_slug}. The slug is available in the Netlify UI at Team settings > General > Team details > Team information. An account in the Netlify REST API is equivalent to a team in the UI. Whenever the API requires an {account_id}, you can substitute {account_slug}. These two are interchangeable whenever they’re used in API paths. #Create and update environment variables POST /api/v1/accounts/{account_id}/env creates site or shared environment variables with the specified scopes and contextual values. An environment variable’s contextual values are the different values set for use in each deploy context.  PUT /api/v1/accounts/{account_id}/env/{key} updates an existing environment variable by replacing all of its values with the values provided with this request.  PATCH /api/v1/accounts/{account_id}/env/{key} updates or creates a new value for an existing environment variable.  #Delete environment variables DELETE /api/v1/accounts/{account_id}/env/{key} deletes an environment variable and all of its values.  DELETE /api/v1/accounts/{account_id}/env/{key}/value/{id} deletes a specific environment variable value.  #Files All files deployed by Netlify can be read through the API. Where the public URL of a file will serve the processed version for HTML pages, the files accessed through the API are the original uploaded files.  Netlify is based on a concept of atomic deploys. This means you never work on individual files. If you want to change a file, you do a new deploy with a new version of the site. To delete a file, you create a new deploy without the file. The file digest based deployment method means that these operations are fast and low-cost. Atomic deploys guarantees that your site is never in an inconsistent state where some files are being uploaded and where users might get HTML files that are not in sync with the CSS, image files, etc.  #Get files GET /api/v1/sites/{site_id}/files returns a list of all the files in the current deploy.  [   {     \"id\": \"/index.html\",     \"path\": \"/index.html\",     \"sha\": \"20828dcdf2cd07e5980fe52759101591bf5014ab\",     \"mime_type\": \"text/html\",     \"size\": 27232   } ]  #Get file GET /api/v1/sites/{site_id}/files/{file_path} returns the file.  {   \"id\": \"/index.html\",   \"path\": \"/index.html\",   \"sha\": \"20828dcdf2cd07e5980fe52759101591bf5014ab\",   \"mime_type\": \"text/html\",   \"size\": 27232 }  You can get the raw contents of the file by using the custom media type application/vnd.bitballoon.v1.raw as the Content-Type of your HTTP request.  #Deploys You can access all deploys for a specific site.  #Get deploys GET /api/v1/sites/{site_id}/deploys returns a list of all deploys for a site.  [   {     \"id\": \"52465f435803544542000001\",     \"premium\": false,     \"claimed\": true,     \"name\": \"synergy\",     \"custom_domain\": \"www.example.com\",     \"notification_email\": \"me@example.com\",     \"url\": \"http://www.example.com\",     \"deploy_url\": \"http://52465f435803544542000001.some-site.netlify.app\",     \"admin_url\": \"https://api.netlify.com/sites/synergy\",     \"screenshot_url\": null,     \"created_at\": \"2013-09-17T05:13:08Z\",     \"updated_at\": \"2013-09-17T05:13:19Z\",     \"user_id\": \"51f60d2d5803545326000005\",     \"state\": \"old\"   } ]  #Get deploy GET /api/v1/sites/{site_id}/deploys/{deploy_id} returns a specific deploy.  {   \"id\": \"52465f435803544542000001\",   \"premium\": false,   \"claimed\": true,   \"name\": \"synergy\",   \"custom_domain\": \"www.example.com\",   \"notification_email\": \"me@example.com\",   \"url\": \"http://www.example.com\",   \"deploy_url\": \"http://52465f435803544542000001.some-site.netlify.app\",   \"admin_url\": \"https://api.netlify.com/sites/synergy\",   \"screenshot_url\": null,   \"created_at\": \"2013-09-17T05:13:08Z\",   \"updated_at\": \"2013-09-17T05:13:19Z\",   \"user_id\": \"51f60d2d5803545326000005\",   \"state\": \"old\" }  #Restore deploy (rollback) POST /api/v1/sites/{site_id}/deploys/{deploy_id}/restore restores an old deploy and makes it the live version of the site.  {   \"id\": \"52465f435803544542000001\",   \"premium\": false,   \"claimed\": true,   \"name\": \"synergy\",   \"custom_domain\": \"www.example.com\",   \"notification_email\": \"me@example.com\",   \"url\": \"http://www.example.com\",   \"deploy_url\": \"http://52465f435803544542000001.some-site.netlify.app\",   \"admin_url\": \"https://api.netlify.com/sites/synergy\",   \"screenshot_url\": null,   \"created_at\": \"2013-09-17T05:13:08Z\",   \"updated_at\": \"2013-09-17T05:13:19Z\",   \"user_id\": \"51f60d2d5803545326000005\",   \"state\": \"current\" }  #Snippets Snippets are code snippets that are injected into every HTML page of the website, either right before the closing head tag or right before the closing body tag.  Each snippet can specify code for all pages and code that gets injected into “Thank you” pages shown after a successful form submission.  #Get snippets GET /api/v1/sites/{site_id}/snippets gets a list of snippets specific to a site.  [   {     \"id\": 0,     \"title\": \"Test\",     \"general\": \"\\u003Cscript\\u003Ealert(\\\"Hello\\\")\\u003C/script\\u003E\",     \"general_position\": \"head\",     \"goal\": \"\",     \"goal_position\": \"footer\"   } ]  The general property is the code that will be injected right before either the head or body end tag. The general_position can be head or footer and determines whether to inject the code in the head element or before the closing body tag.  The goal property is the code that will be injected into the “Thank you” page after a form submission. goal_position determines where to inject this code.  #Get snippet GET /api/v1/sites/{site_id}/snippets/{snippet_id} gets a specific snippet.  {   \"id\": 0,   \"title\": \"Test\",   \"general\": \"\\u003Cscript\\u003Ealert(\\\"Hello\\\")\\u003C/script\\u003E\",   \"general_position\": \"head\",   \"goal\": \"\",   \"goal_position\": \"footer\" }  #Add snippet POST /api/v1/sites/{site_id}/snippets adds a new snippet to a site.  #Update snippet PUT /api/v1/sites/{site_id}/snippets/{snippet_id} replaces a snippet.  #Delete snippet DELETE /api/v1/sites/{site_id}/snippets/{snippet_id} deletes a snippet.  #Forms You can access all Netlify Forms metadata and submissions for a site.  #Get forms GET /api/v1/sites/{site_id}/forms returns a list of all forms for a site, including metadata about each form, but not including form submissions.  [   {     \"id\": \"ac0865cc46440b1e64666f520e8d88d670c8a2f6\",     \"site_id\": \"0d3a9d2f-ef94-4380-93df-27ee400e2048\",     \"name\": \"Landing Page\",     \"paths\": [\"/index\"],     \"submission_count\": 3,     \"fields\": [       { \"name\": \"name\", \"type\": \"text\" },       { \"name\": \"email\", \"type\": \"email\" },       { \"name\": \"phone\", \"type\": \"text\" },       { \"name\": \"company\", \"type\": \"text\" },       { \"name\": \"website\", \"type\": \"url\" },       { \"name\": \"number_of_employees\", \"type\": \"select\" }     ],     \"created_at\": \"2013-09-18T20:26:19Z\"   } ]  #Get verified submissions GET /api/v1/sites/{site_id}/submissions returns a list of verified form submissions across all forms for a specific site.  GET /api/v1/forms/{form_id}/submissions returns a list of verified form submissions for a specific form.  [   {     \"id\": \"5231110b5803540aeb000019\",     \"number\": 13,     \"title\": null,     \"email\": \"test@example.com\",     \"name\": \"Mathias Biilmann\",     \"first_name\": \"Mathias\",     \"last_name\": \"Biilmann\",     \"company\": \"Netlify\",     \"summary\": \"Hello, World\",     \"body\": \"Hello, World\",     \"data\": {       \"email\": \"test@example.com\",       \"name\": \"Mathias Biilmann\",       \"ip\": \"127.0.0.1\"     },     \"created_at\": \"2013-09-12T00:55:39Z\",     \"site_url\": \"http://synergy.netlify.app\"   } ]  #Get spam submissions To get spam submissions, add a state=spam query parameter to the URL:  GET /api/v1/sites/{site_id}/submissions?state=spam returns a list of spam form submissions across all forms for a specific site.  GET /api/v1/forms/{form_id}/submissions?state=spam returns a list of spam form submissions for a specific form.  #Change submission state You can change the state of a submission from spam to verified or vice versa.  PUT /api/v1/submissions/{submission_id}/spam marks the submission as spam.  PUT /api/v1/submissions/{submission_id}/ham marks the submission as verified.  #Delete submissions DELETE /api/v1/submissions/{submission_id} removes a form submission.  #Delete form DELETE /api/v1/sites/{site_id}/forms/{form_id} removes a form and any existing submissions to it.  Future submissions to the form will result in a 404 error, and previous submissions will no longer be available.  #Hooks Netlify can trigger webhooks, send email notifications, or send Slack messages on certain events.  The /hooks endpoint lets you control the hooks for your site.  #Get hook types GET /api/v1/hooks/types returns a list of types of hooks that you can configure on Netlify.  [   {     \"name\": \"url\",     \"fields\": [       {         \"name\": \"url\",         \"options\": {           \"type\": \"string\",           \"title\": \"URL to notify\"         }       }     ],     \"events\": [\"submission_created\", \"deploy_created\", \"deploy_failed\"]   } ]  Each type has a series of fields that you need to set to create a new hook, and a list of events that can trigger them.  #Get hooks for a site GET /api/v1/hooks?site_id={site_id} returns a list of a hooks defined for a specific site.  [   {     \"id\": \"5636b7a00d61eec2d6001004\",     \"site_id\": \"0d3a9d2f-ef94-4380-93df-27ee400e2048\",     \"type\": \"email\",     \"event\": \"submission_created\",     \"data\": { \"email\": \"test@example.com\" },     \"created_at\": \"2015-10-20T21:51:51Z\",     \"updated_at\": \"2015-10-20T21:51:51Z\"   } ]  #Create hook POST /api/v1/hooks creates a new hook.  An example request body for an email hook for a specific form in your site would be formatted like this:  {   \"site_id\": \"0d3a9d2f-ef94-4380-93df-27ee400e2048\",   \"form_id\": \"5235a7a00d61eec2d6001302\",   \"type\": \"email\",   \"event\": \"submission_created\",   \"data\": { \"email\": \"test@example.com\" } }  form_id is optional and links the hook to a specific form within your site. You can also use form_name with the value of the name attribute of the form of your site as an alternative to form_id.  #Delete hook DELETE /api/v1/hooks/{hook_id} removes a hook permanently.  Note, for outgoing webhooks, returning a 410 Gone status code from the URL endpoint will trigger a deletion of the hook.\n\n\n\nOAuth Quickstart API: 1. Choose a JWT library As your API will be parsing JWT formatted access tokens, you will need to setup these capabilities on your API.  You can navigate to jwt.io  and choose from there. Remember to pick a library that support your selected signing algorithm.  2. Configuring your API to accept RS256 signed tokens Configure the library that will validate the access tokens in your API. Validating a token means that you are certain you can trust its contents.  const express = require('express'); const app = express(); const { auth } = require('express-oauth2-jwt-bearer');  const port = process.env.PORT || 8080;  const jwtCheck = auth({   audience: 'https://carsontkempf.github.io/account/',   issuerBaseURL: 'https://dev-l57dcpkhob0u7ykb.us.auth0.com/',   tokenSigningAlg: 'RS256' });  // enforce on all endpoints app.use(jwtCheck);  app.get('/authorized', function (req, res) {     res.send('Secured Resource'); });  app.listen(port);  console.log('Running on port ', port);\n\n\n\nOAuth Application Settings: Application Settings On the Applications page of the Dashboard, locate your application in the list, and click its name to view the available settings.  Dashboard Applications List Basic settings When you edit an existing application's settings or create a new application, you enter information about the application in the Settings view.  Basic Information Dashboard Applications Application Settings Tab Basic Information Name: The name of your application. Editable, and will be seen in the portal, emails, logs, and so on.  Domain: Your Auth0 tenant name. You choose this when you create a new Auth0 tenant, and it cannot be changed. If you need a different domain, you must register for a new tenant by selecting + Create Tenant in the top-right menu.  Client ID: The unique identifier for your application. You will use this when configuring authentication with Auth0. Generated by the system when you create a new application and cannot be modified.  Client Secret: A string used to sign and validate ID Tokens for authentication flows and to gain access to select Auth0 API endpoints. By default, the value is hidden, so check the Reveal Client Secret box to see it. While the Client ID is considered public information, the Client Secret must be kept confidential. If anyone can access your Client Secret, they can issue tokens and access resources they shouldn't be able to access.  Description: A free-text description of the Application's purpose. Maximum of 140 characters.  Application Properties Dashboard Applications Application Settings Tab Application Properties Application Logo: The URL of a logo (recommended size: 150x150 pixels) to display for the application. Appears in several areas, including the list of applications in the Dashboard and customized consent forms. If none is set the default badge for this type of application will be shown.  Application Type: The Auth0 application type determines which settings you can configure using the Dashboard. (Not editable for M2M apps. Sometimes disabled for other Auth0 application types if the selected grant types are only allowed for the currently selected application type.) Use the drop-down to select from the following types:  Machine to Machine: Non-interactive applications, such as command-line tools, daemons, IoT devices, or services running on your backend. Typically, you use this option if you have a service that requires access to an API.  Native App: Mobile or Desktop applications that run natively in a device (such as iOS or Android).  Regular Web App: Traditional web apps that perform most of their application logic on the server (such as Express.js or ASP.NET).  Single Page App: JavaScript apps that perform most of their user interface logic in a web browser, communicating with a web server primarily using APIs (such as AngularJS + Node.js or React).   Application URIs Dashboard Applications Application Settings Application URIs Application Login URI: In some scenarios, Auth0 will need your application to redirect to your application's login page. This URI needs to point to a route in your application that redirects to your tenant's /authorize endpoint. It would usually take the form of https://myapp.org/login. To learn more, read Configure Default Login Routes.  Allowed Callback URLs: Set of URLs to which Auth0 is allowed to redirect users after they authenticate. You can specify multiple valid URLs by comma-separating them (typically, to handle different environments like QA or testing). For production environments, verify that the URLs do not point to localhost. You can use the star symbol as a wildcard placeholder for subdomains (*.google.com). If you are using the Organizations feature, for production applications, you can use {organization_name} as a placeholder to dynamically specify a registered organization’s name in a URL (https://{organization_name}.exampleco.com). URLs with the {organization_name} placeholder should only be used on domains that you fully control (for example, https://{organization_name}.exampleco.com where you control the exampleco.com domain).  Do not use wildcard placeholders or localhost URLs in your application callbacks or allowed origins fields. Using redirect URLs with wildcard placeholders can make your application vulnerable to attacks. To learn more, read Unvalidated Redirects and Forwards Cheat Sheet on owasp.org. Instead, URLs with the {organization_name} placeholder should be preferred, where relevant. To learn more, read Subdomain URL Placeholders.  Allowed Logout URLs: After a user logs out from Auth0 you can redirect them with the returnTo query parameter. The URL that you use in returnTo must be listed here. You can specify multiple valid URLs by comma-separating them. For production environments, verify that the URLs do not point to localhost. You can use the star symbol as a wildcard placeholder for subdomains (*.google.com). Notice that query strings and hash information are not taken into account when validating these URLs. See Logout. You can provide up to 100 URLs in the Allowed Logout URLs field.  Allowed Web Origins: List of URLs from where an authorization request using Cross-Origin Authentication, Device Flow, and web_message as the response mode can originate from. You can specify multiple valid URLs by comma-separating them. For production environments, verify that the URLs do not point to localhost. You can use the star symbol as a wildcard placeholder for subdomains (*.google.com). Paths, query strings, and hash information are not taken into account when validating these URLs (and may, in fact, cause the match to fail). You can provide up to 100 URLs in the Allowed Web Origins field.  ID Token In the ID Token section, enter the ID Token Expiration (in seconds) which is the amount of time before the Auth0 id_token expires. The default value is 36000 seconds which is 10 hours.   Use Auth0 instead of the IdP to do Single Sign-on: If enabled, this setting prevents Auth0 from redirecting authenticated users with valid sessions to the identity provider (such as Facebook or ADFS). Legacy tenants only.  Refresh Token Rotation In the Refresh Token Rotation section, enable or disable rotation. When enabled, as a result of exchanging a refresh token, a new refresh token will be issued and the existing token will be invalidated. This allows for automatic detection of token reuse if the token is leaked. In addition, enter the Rotation Overlap Period (in seconds). This interval is the allowable leeway time that the same refresh_token can be used to request an access_token without triggering automatic reuse detection. To learn more, read Refresh Token Rotation.  Dashboard Applications Applications Settings Tab Refresh Token Rotation Refresh Token Expiration In the Refresh Token Expiration section, enable or disable absolute and inactivity expiration and set the lifetimes (in seconds) for each. To learn more, read Configure Refresh Token Expiration.  Dashboard Applications Applications Settings Tab Refresh Token Expiration Advanced settings The Advanced Settings section allows you to:  Manage or add application metadata, device, OAuth, and WS-Federation settings  Obtain certificates and Token endpoint information  Set the grant type(s) for the application  Application Metadata Application metadata are custom string keys and values (each of which has a character maximum of 255), set on a per-application basis. Metadata is exposed in the application object as client_metadata, and in rules as context.clientMetadata. You can create up to 10 sets of metadata.  Dashboard Applications Applications Settings Tab Advanced Settings Application Metadata Tab Device Settings If you're developing a mobile application, enter the necessary iOS/Android parameters.  When developing iOS apps, you'll provide your Team ID and App ID. To learn more, read Enable Universal Links Support in Apple Xcode.  When developing Android apps, you'll provide your App Package Name and your Key Hashes. To learn more, read Enable Android App Links Support.  Dashboard Applications Application Settings Tab Advanced Settings Device Settings Tab OAuth Dashboard Applications Application Settings Tab Advanced Settings OAuth Tab By default, all apps/APIs can make a delegation request, but if you want to explicitly grant permissions to selected apps/APIs, you can do so in Allowed Apps/APIs.  For customers using the Highly Regulated Identity add-on, use the Compliance Enforcement Level setting to set your level of compliance. For more information, review Configure FAPI Compliance.  Set the algorithm used ( HS256  or  RS256 ) for signing your JSON web tokens. To learn more, read JSON Web Token Signing Algorithms. When selecting RS256 (recommended), the token will be signed with your tenant's private key.  Toggle the Trust Token Endpoint IP Header setting; if this is enabled, the auth0-forwarded-for is set as trusted and used as a source of end user IP information for protection against brute-force attacks on the Token endpoint. This setting is only available for Regular Web Apps and M2M Apps.  Toggle the switch to indicate if your application is OIDC Conformant or not. Applications flagged as OIDC Conformant will strictly follow the OIDC specification.  For troubleshooting help, read Troubleshoot Invalid Token Errors.  Grant Types Select grant types to enable or disable for your application. Available grant types are based on the application type.  Dashboard Applications Application Settings Tab Advanced Settings Grant Types tab WS-Federation Manage or add WS-Federation settings.  Dashboard Applications Application Settings Tab Advanced WS-Federation tab Certificates Manage or add the signing certificate, and its fingerprint and thumbprint.  Dashboard Applications Advanced Settings Certificates tab Endpoints View endpoint information for OAuth, SAML, and WS-Fed, such as Authorization and Metadata URLs.\n\n\n\nJavascript OAuth Quickstart: JavaScript: Login Gravatar for steve.hobbs@auth0.com By Steve Hobbs This tutorial demonstrates how to add user login to a Javascript application using Auth0.  I want to integrate with my app 15 minutes Configure Auth0 Integrate Auth0 in your Application Setting Up the Application Create the server Initialize the SDK Evaluate the authentication state Log In to the Application Log the User Out Read the User Profile Or I want to explore a sample app 2 minutes Get a sample configured with your account settings or check it out on Github.  New to Auth? Learn How Auth0 works, how it integrates with Single-Page Applications and which protocol it uses.  Configure Auth0 Get Your Application Keys When you signed up for Auth0, a new application was created for you, or you could have created a new one. You will need some details about that application to communicate with Auth0. You can get these details from the Application Settings section in the Auth0 dashboard.  App Dashboard  When using the Default App with a Native or Single Page Application, ensure to update the Token Endpoint Authentication Method to None and set the Application Type to either SPA or Native.  You need the following information:  Domain Client ID If you download the sample from the top of this page, these details are filled out for you.  Configure Callback URLs A callback URL is a URL in your application where Auth0 redirects the user after they have authenticated. The callback URL for your app must be added to the Allowed Callback URLs field in your Application Settings. If this field is not set, users will be unable to log in to the application and will get an error.  If you are following along with the sample project you downloaded from the top of this page, you should set the Allowed Callback URL to http://localhost:3000.  Configure Logout URLs A logout URL is a URL in your application that Auth0 can return to after the user has been logged out of the authorization server. This is specified in the returnTo query parameter. The logout URL for your app must be added to the Allowed Logout URLs field in your Application Settings. If this field is not set, users will be unable to log out from the application and will get an error.  If you are following along with the sample project you downloaded from the top of this page, the logout URL you need to add to the Allowed Logout URLs field is http://localhost:3000.  Configure Allowed Web Origins You need to add the URL for your app to the Allowed Web Origins field in your Application Settings. If you don't register your application URL here, the application will be unable to silently refresh the authentication tokens and your users will be logged out the next time they visit the application, or refresh the page.  If you are following along with the sample project you downloaded from the top of this page, you should set the Allowed Web Origins to http://localhost:3000.    Integrate Auth0 in your Application Use the Auth0 SPA SDK library to integrate Auth0 into your application. You can either install the library as a dependency in your application, or load it from CDN.  Install as a dependency You can install the Auth0 SPA SDK as a dependency of your application, useful if you're using a build system such as Webpack. You can do this using npm or yarn.  # installation with npm npm install --save @auth0/auth0-spa-js  # installation with yarn yarn add @auth0/auth0-spa-js Was this helpful?  / Once the Auth0 SPA SDK is installed, reference it using an import statement at the entrypoint of your application ():  import { createAuth0Client } from '@auth0/auth0-spa-js'; Was this helpful?  / Reference the CDN Alternatively, if you do not use a package manager such as Webpack, you can retrieve the Auth0 SPA SDK from Auth0's CDN.  <script src=\"https://cdn.auth0.com/js/auth0-spa-js/2.0/auth0-spa-js.production.js\"></script> Was this helpful?  / If you encounter some problems or errors when using the new JavaScript SDK, please check out the FAQ to see if your issue is covered there.  Authentication with Auth0 Universal Login is the easiest way to set up authentication in your application. We recommend using it for the best experience, best security and the fullest array of features. This guide will use it to provide a way for your users to log in to your JavaScript application.  You can also embed the login dialog directly in your application using the Lock widget. If you use this method, some features, such as single sign-on, will not be accessible.  When a user logs in, Auth0 returns three items:  access_token: to learn more, see the Access Token documentation id_token: to learn more, see the ID Token documentation expires_in: the number of seconds before the Access Token expires You can use these items in your application to set up and manage authentication.  Setting Up the Application Create a basic HTML page Create a folder on your machine to house the application, then add an index.html file to the root of the project. This HTML page will display a welcome message and have a \"gated\" section which requires the user to be authenticated before accessing. You can copy/paste the following content into the file. You will be adding more lines as you progress with this article.  Add the following content to the index.html file you just created:  <!DOCTYPE html> <html>   <head>     <meta charset=\"UTF-8\" />     <title>SPA SDK Sample</title>     <link rel=\"stylesheet\" type=\"text/css\" href=\"/css/main.css\" />   </head>    <body>     <h2>SPA Authentication Sample</h2>     <p>Welcome to our page!</p>     <button id=\"btn-login\" disabled=\"true\" onclick=\"login()\">Log in</button>     <button id=\"btn-logout\" disabled=\"true\" onclick=\"logout()\">Log out</button>   </body> </html> Was this helpful?  / Additionally, create a new folder called public, a folder inside that called css and a new file in there called main.css. This will be used to define how the gated content elements will be hidden in the page.  Open the newly-created public/css/main.css file and add the following CSS:  .hidden {   display: none; }  label {   margin-bottom: 10px;   display: block; } Was this helpful?  / Finally, create a new directory in the public folder called js, and a new file in there called app.js. This will house the application-specific logic that you will create over the next few sections.  The folder structure so far should look like the following:  . ├── index.html └── public     ├── css     │   └── main.css     └── js         └── app.js Was this helpful?  / Reference the SDK This article is based on the new SPA SDK available here. You can reference the package from the CDN in the index.html file by placing the script tags at the very bottom of the body tag:  <body>      <!-- other HTML -->      <!-- add the lines below existing code -->   <script src=\"https://cdn.auth0.com/js/auth0-spa-js/2.0/auth0-spa-js.production.js\"></script>   <script src=\"js/app.js\"></script> </body> Was this helpful?  / Configure credentials Create an auth_config.json in the root of the project. The values from domain and clientId should be populated from your Auth0 application settings as configured above.  {   \"domain\": \"dev-l57dcpkhob0u7ykb.us.auth0.com\",   \"clientId\": \"Dq4tBsHjgcIGbXkVU8PPvjAq3WYmnSBC\" } Was this helpful?  / As auth_config.json is served publicly, this file should never contain sensitive information such as passwords and client secrets.  Create the server In this section you will create a basic web server using ExpressJS. This will be used to serve our HTML page, along with any assets that it requires (JavaScript, CSS, etc).  Run the following command in the same folder as the index.html file you created earlier:  npm init -y Was this helpful?  / This will initialize a new NPM project and get us ready to install dependencies.  Installing dependencies In the terminal, install the dependencies that are necessary to get the server up and running:  npm install express Was this helpful?  / Also install  nodemon  so that our server can be restarted on any code changes:  npm install -D nodemon Was this helpful?  / Finally, open the package.json file and modify the \"scripts\" entry to look like the following:  {   // ...   \"scripts\": {     \"start\": \"node server.js\",     \"dev\": \"nodemon server.js\"   },   // ... } Was this helpful?  / npm start will run the application as normal npm run dev will run the application using nodemon, watching for changes as we modify files Creating server.js Next, create a new file in the root of the project alongside index.html and package.json, called server.js. This will be our backend server and will be used to serve the SPA pages.  Populate server.js with the following code:  const express = require(\"express\"); const { join } = require(\"path\"); const app = express();  // Serve static assets from the /public folder app.use(express.static(join(__dirname, \"public\")));  // Endpoint to serve the configuration file app.get(\"/auth_config.json\", (req, res) => {   res.sendFile(join(__dirname, \"auth_config.json\")); });  // Serve the index page for all other requests app.get(\"/*\", (_, res) => {   res.sendFile(join(__dirname, \"index.html\")); });  // Listen on port 3000 app.listen(3000, () => console.log(\"Application running on port 3000\")); Was this helpful?  / The server provides two endpoints:  one which serves the authentication configuration file to the client-side app another which serves every other request to the index.html file, which will provide support for any client-side routing as all routes go to the same page The app also serves all of the static files, such as the .js and .css files from the /public folder.  Initialize the SDK The SDK must be properly initialized with the information of the Auth0 application created above.  To start, open the public/js/app.js file and add a variable to hold the Auth0 client object:  let auth0Client = null; Was this helpful?  / This must be initialized using the values from the auth_config.json file. This can be done by calling the endpoint on the server that was created in the previous section. To do this, create a new function called fetchAuthConfig further down the app.js file, which can be used to download this information:  // ..  const fetchAuthConfig = () => fetch(\"/auth_config.json\"); Was this helpful?  / Next, create another new function called configureClient. This will use fetchAuthConfig to download the configuration file and initialize the auth0Client variable:  // ..  const configureClient = async () => {   const response = await fetchAuthConfig();   const config = await response.json();    auth0Client = await auth0.createAuth0Client({     domain: config.domain,     clientId: config.clientId   }); }; Was this helpful?  / This call will also populate the in-memory cache with a valid access token and user profile information if someone has already authenticated before and that session is still valid.  Add a handler for the window.onload function that will then make this call to initialize the application:  // ..  window.onload = async () => {   await configureClient(); } Was this helpful?  / Now go and access it at http://localhost:3000. You should see the welcome message and both authentication buttons disabled. Note however that some browsers cache the page sources. When checking each step results you should perform a full page refresh ignoring the cache. This can be achieved by using the CMD+SHIFT+R keys on OSX and CTRL+SHIFT+R keys on Windows.  Restoring Login State with Social Providers Users who are logged in with username/password will be silently reauthenticated automatically when the application reloads. No further action is needed for this type of login.  If you are using the classic Universal Login experience and would like users to authenticate using  social identity providers  (such as Google, Apple, Facebook, etc.), then you will need to configure those connections in your Auth0 Dashboard.  In the navigation menu, choose Connections - Social, and select the social connection you’d like to support. In the connection’s settings, click “How to obtain a Client ID?“ and follow the instructions to set up your own ID and secret.  If you are using the new Universal Login experience, the default enabled social connections will silently reauthenticate without additional configuration. However, you should still set up your own keys and avoid using default Auth0 development keys in a production app.  Evaluate the authentication state As a first approach, you want to make sure anyone is able to visit the public page but not the page that is meant for authenticated users only, such as a settings panel or the user profile details. You can decide which content is available by hiding, disabling, or removing it if no user is currently logged in. You do so by checking the result of calling the auth0Client.isAuthenticated() method. Use this to enable or disable the Log in and Log out buttons, which are disabled by default. This can be part of a new updateUI() function called from the window.onload method right after the initialization.  Still inside the app.js file, add a new function called updateUI and modify the onload handler to call this new function:  // ..  window.onload = async () => {   await configureClient();    // NEW - update the UI state   updateUI(); };  // NEW const updateUI = async () => {   const isAuthenticated = await auth0Client.isAuthenticated();    document.getElementById(\"btn-logout\").disabled = !isAuthenticated;   document.getElementById(\"btn-login\").disabled = isAuthenticated; }; Was this helpful?  / Checkpoint: If you run the project again, you should see that the \"Log in\" button is shown as enabled as no user has previously logged in. But clicking it will not do anything as there is no logic associated to that action yet.  Log In to the Application Authentication is achieved through a redirect to the Auth0 Universal Login Page. Once the user signs up or logs in, the result will be passed to your app's redirect URI, which is provided with the authorization request.  Inside the app.js file, provide a login function that calls auth0Client.loginWithRedirect() to perform the login step. The login function is called by the Log in button previously defined in the HTML page. In this sample, you will redirect the user back to the same page they are now. You can obtain that value from window.location.origin property:  // ..  const login = async () => {   await auth0Client.loginWithRedirect({     authorizationParams: {       redirect_uri: window.location.origin     }   }); }; Was this helpful?  / Additionally, because this is a single page application, the result of this call needs to be handled in the same context. This means that when the page is loaded and the user is not authenticated you could be in one of the following two scenarios:  The user does not want to authenticate and is just navigating through public content or The user has recently initiated the authentication process and is now looking to complete it. This second scenario is the one you need to handle. In your window.onload method, check whether the user is authenticated or not, and if the URL query contains both a code and state parameter. This will indicate that an authentication result is present and needs to be parsed. In that scenario, you do so by calling the auth0Client.handleRedirectCallback() method. This will attempt to exchange the result that the Auth0 backend gave you back for real tokens you can use.  In addition, the query parameters must be removed from the URL so that if the user refreshes the page, the app does not try to parse the state and code parameters again. This is achieved with the window.history.replaceState method.  Modify the window.onload function inside app.js to include these changes:  // ..  window.onload = async () => {    // .. code ommited for brevity    updateUI();    const isAuthenticated = await auth0Client.isAuthenticated();    if (isAuthenticated) {     // show the gated content     return;   }    // NEW - check for the code and state parameters   const query = window.location.search;   if (query.includes(\"code=\") && query.includes(\"state=\")) {      // Process the login state     await auth0Client.handleRedirectCallback();          updateUI();      // Use replaceState to redirect the user away and remove the querystring parameters     window.history.replaceState({}, document.title, \"/\");   } };  // .. Was this helpful?  / The callback is now handled properly and the authentication can be completed successfully.  Run the project and click the Log in button. You should be taken to the Universal Login Page configured for your application. Go ahead and create a new user or log in using a social connection. After authenticating successfully, you will be redirected to the page you were before. This time, the result will be present in the URL query and the exchange will happen automatically. If everything went fine, you will end up with no query parameters in the URL, the user would now be logged in and the \"Log out\" button will be enabled.  If you see any errors from the Auth0 server, check that you have not forgotten to register the callback URL or the allowed origins as explained initially.  Log the User Out You may have noticed that the Log out button is clickable when the user is authenticated, but does nothing. You need to add the code that will log the user out from the Auth0 backend.  Start the log out by calling the auth0Client.logout() method passing a valid return-to URI. In this sample you will return the user back to the same page they are now. You can obtain that value from window.location.origin property. Abstract this logic into a logout() method.  // public/js/app.js  const logout = () => {   auth0Client.logout({     logoutParams: {       returnTo: window.location.origin     }   }); }; Was this helpful?  / Checkpoint: Being authenticated click the Log out button. You should be taken to the Universal Login Page configured for your application and then back to the page you were before. Now the authentication cookies were cleared and the user is logged out. The \"Log in\" button will be enabled back again.  If you see any errors from the Auth0 server, check that you have not forgotten to register the logout URL as explained initially.  Read the User Profile Every time a user is logged in you get access both to the access token and the ID token. The user's profile information is then extracted from the ID token. Typically, the token is used to call your backend application and the profile information is used to display their name and profile picture. In this section you are going to display them in separate text areas so you can easily inspect them.  Open the index.html file and insert the following lines at the bottom of the body.  <body>   <!-- ... -->    <div class=\"hidden\" id=\"gated-content\">     <p>       You're seeing this content because you're currently       <strong>logged in</strong>.     </p>     <label>       Access token:       <pre id=\"ipt-access-token\"></pre>     </label>     <label>       User profile:       <pre id=\"ipt-user-profile\"></pre>     </label>   </div>      <!-- .. existing script tags .. --> </body> Was this helpful?  / Now re-open the app.js file and modify the updateUI() function declared previously. Add the logic such that when the user is logged in the gated content is shown. Use the existing variables and functions from the SDK client to obtain and display this information on the page.  In addition, at the start of this article you added a public/css/main.css file with the definition of the hidden class, which can be used to easily hide elements on the page. Using the authenticated flag as shown below, add or remove this class to the elements you want to show or hide in the updateUI() function:  // ...  const updateUI = async () => {    const isAuthenticated = await auth0Client.isAuthenticated();    document.getElementById(\"btn-logout\").disabled = !isAuthenticated;   document.getElementById(\"btn-login\").disabled = isAuthenticated;      // NEW - add logic to show/hide gated content after authentication   if (isAuthenticated) {     document.getElementById(\"gated-content\").classList.remove(\"hidden\");      document.getElementById(       \"ipt-access-token\"     ).innerHTML = await auth0Client.getTokenSilently();      document.getElementById(\"ipt-user-profile\").textContent = JSON.stringify(       await auth0Client.getUser()     );    } else {     document.getElementById(\"gated-content\").classList.add(\"hidden\");   } };  // .. Was this helpful?  / Note that calls to the SDK instance can throw an exception if the authentication fails, if there is no user currently authenticated, or if the access token needs to be refreshed and that request fails. You will need to put a try/catch block around them to correctly handle any errors. These error checks are not shown on the article but they are available on the final sample app that you can download.\n\n\n\nOAuth Calling an API: JavaScript: Calling an API Gravatar for steve.hobbs@auth0.com By Steve Hobbs This tutorial demonstrates how to make API calls for protected resources on your server.  I want to integrate with my app 15 minutes Create an API Create a Backend API Calling the API Or I want to explore a sample app 2 minutes Get a sample configured with your account settings or check it out on Github.  Most single-page apps use resources from data APIs. You may want to restrict access to those resources, so that only authenticated users with sufficient privileges can access them. Auth0 lets you manage access to these resources using API Authorization.  This tutorial shows you how to access protected resources in your API.  This tutorial does not show you how to add protection to your API. Read the Backend/API quickstart documentation for instructions on how to protect your API.  Create an API In the APIs section of the Auth0 dashboard, click Create API. Provide a name and an identifier for your API. You will use the identifier later when you're configuring your Javascript Auth0 application instance. For Signing Algorithm, select RS256.  Create API  Create a Backend API In this section, you will modify the ExpressJS that you created in part 1 so that it supports a new endpoint. This endpoint will require a valid access token to be sent in the Authorization header for the call to be successful.  Add middleware to the backend To begin, let's install an NPM package that will be used to validate incoming tokens to the server. From the terminal:  npm install express-oauth2-jwt-bearer Was this helpful?  / Next, open server.js and bring in these libraries as imports at the top of the file. Also bring in the auth_config.json file so that the script can get access to the authentication credentials that have been configured:  // .. other imports  const { auth } = require(\"express-oauth2-jwt-bearer\"); const authConfig = require(\"./auth_config.json\"); Was this helpful?  / express-oauth2-jwt-bearer  - validates JWTs from the authorization header and sets the req.auth object Then add a call to auth(), which creates the middleware needed in order to validate and parse incoming access tokens. This should go after the require statements but before any routes are defined in your app:  // create the JWT middleware const checkJwt = auth({   audience: authConfig.audience,   issuerBaseURL: `https://${authConfig.domain}` }); Was this helpful?  / This code configures the express-oauth2-jwt-bearer middleware with the settings that relate to your Auth0 application.  Next, open the auth_config.json file and modify the data so that the audience appears as a key within the JSON, using the value that you just used when creating the API:  Configured withApplication:CarsonKempf CarsonKempf API:CarsonKempf CarsonKempf {   \"domain\": \"dev-l57dcpkhob0u7ykb.us.auth0.com\",   \"clientId\": \"moH0QbZSCdnwIryD7FoElVSs3kEvUHbH\",   \"audience\": \"https://carsontkempf.github.io/account/\" } Was this helpful?  / As auth_config.json is served publicly, this file should never contain sensitive information such as passwords and client secrets.  The values for domain and clientId should have already been specified as part of the Login tutorial. They should point to the Domain and Client ID values for your Auth0 app respectively.  Add a protected endpoint The last thing to do on the server side is to add an API endpoint that requires an access token to be provided for the call to succeed. This endpoint will use the middleware that you created earlier in the tutorial to provide that protection in a scalable way.  Open server.js and add a new route for /api/external above the other routes that returns some JSON:  // ..  app.get(\"/api/external\", checkJwt, (req, res) => {   res.send({     msg: \"Your access token was successfully validated!\"   }); });  // .. Was this helpful?  / Note that checkJwt is used as the second argument here. This causes checkJwt to be executed before the main route handler, and will reject the call and return a 401 response if:  there is no access token present in the Authorization header, or the token itself is not valid Finally, add an error handler so that a JSON response is returned from your API in the event of a missing or invalid token:  // ..  app.use(function(err, req, res, next) {   if (err.name === \"UnauthorizedError\") {     return res.status(401).send({ msg: \"Invalid token\" });   }    next(err, req, res); });  //.. Was this helpful?  / At the end, your server.js file will look something like the following:  const express = require(\"express\"); const { auth } = require(\"express-oauth2-jwt-bearer\"); const { join } = require(\"path\"); const authConfig = require(\"./auth_config.json\");  const app = express();  // Serve assets from the /public folder app.use(express.static(join(__dirname, \"public\")));  // Create the JWT validation middleware const checkJwt = auth({   audience: authConfig.audience,   issuerBaseURL: `https://${authConfig.domain}` });  // Create an endpoint that uses the above middleware to // protect this route from unauthorized requests app.get(\"/api/external\", checkJwt, (req, res) => {   res.send({     msg: \"Your access token was successfully validated!\"   }); });  // Serve the auth configuration file app.get(\"/auth_config.json\", (req, res) => {   res.sendFile(join(__dirname, \"auth_config.json\")); });  // Serve the index page to everything else app.get(\"/*\", (req, res) => {   res.sendFile(join(__dirname, \"index.html\")); });  // Error handler app.use(function(err, req, res, next) {   if (err.name === \"UnauthorizedError\") {     return res.status(401).send({ msg: \"Invalid token\" });   }    next(err, req, res); });  module.exports = app; Was this helpful?  / Test the API With this in place, run the application using npm run dev. In another terminal window, use the curl tool to make a request to this API endpoint and observe the results:  curl -I localhost:3000/api/external Was this helpful?  / You should find that a 401 Unauthorized result is returned, because it requires a valid access token:  HTTP/1.1 401 Unauthorized X-DNS-Prefetch-Control: off X-Frame-Options: SAMEORIGIN Strict-Transport-Security: max-age=15552000; includeSubDomains X-Download-Options: noopen X-Content-Type-Options: nosniff X-XSS-Protection: 1; mode=block Content-Security-Policy: default-src 'self' Content-Type: text/html; charset=utf-8 Content-Length: 1582 Date: Wed, 03 Apr 2019 13:10:43 GMT Connection: keep-alive Was this helpful?  / Calling the API Now you can turn your attention to the front-end application. You will update the application to provide a button to call a function which will in turn call the API that you created in the previous section.  Open index.html and add a new button that will invoke the API call, as well as a pre element with an ID of api-call-result to show the result of the API call in the browser:  <button id=\"btn-call-api\" disabled=\"true\" onclick=\"callApi()\">Call Api</button>  <!-- Add a container to hold the response from the call --> <pre id=\"api-call-result\"></pre> Was this helpful?  / Next, open public/js/app.js. Configure the auth0 client object to specify the audience value that was added earlier to the auth_config.json file:  const configureClient = async () => {   const response = await fetchAuthConfig();   const config = await response.json();    auth0 = await auth0Client.createAuth0Client({     domain: config.domain,     clientId: config.clientId,     authorizationParams: {       audience: config.audience   // NEW - add the audience value     }   }); }; Was this helpful?  / Add a new function called callApi to app.js, with the following content:  const callApi = async () => {   try {      // Get the access token from the Auth0 client     const token = await auth0Client.getTokenSilently();      // Make the call to the API, setting the token     // in the Authorization header     const response = await fetch(\"/api/external\", {       headers: {         Authorization: `Bearer ${token}`       }     });      // Fetch the JSON result     const responseData = await response.json();      // Display the result in the output element     const responseElement = document.getElementById(\"api-call-result\");      responseElement.innerText = JSON.stringify(responseData, {}, 2);  } catch (e) {     // Display errors in the console     console.error(e);   } }; Was this helpful?  / Finally, find the updateUI function within app.js and modify it so that the button for calling the API is enabled when the user logs in:  // public/js/app.js  const updateUI = async () => {   const isAuthenticated = await auth0Client.isAuthenticated();    document.getElementById(\"btn-logout\").disabled = !isAuthenticated;   document.getElementById(\"btn-login\").disabled = isAuthenticated;    // NEW - enable the button to call the API   document.getElementById(\"btn-call-api\").disabled = !isAuthenticated;    // .. other code omitted for brevity .. }; Was this helpful?  / Now, open the browser in the application at http://localhost:3000. If the application has been stopped, run it again from the terminal using npm run dev.  When the application starts, log in. Then, press the Call API button to make a request to the API and put the results on the screen. You should find that the result from the server is displayed on the page.",
    "ctk.ruleSet": [
        {
            "id": 1,
            "key": "OAuth Quickstart"
        },
        {
            "id": 2,
            "key": "Sample OAuth Application README"
        },
        {
            "id": 3,
            "key": "Netlify API Documentation"
        },
        {
            "id": 4,
            "key": "OAuth Quickstart API"
        },
        {
            "id": 5,
            "key": "OAuth Application Settings"
        },
        {
            "id": 6,
            "key": "Javascript OAuth Quickstart"
        },
        {
            "id": 7,
            "key": "OAuth Calling an API"
        }
    ]
}



