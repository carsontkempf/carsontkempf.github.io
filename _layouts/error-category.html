---
layout: default
---
        <!-- Extract category slug from page URL -->
        {% assign url_parts = page.url | split: '/' %}
        {% assign category_slug = url_parts[-2] %}
        
        <!-- Find the category data -->
        {% assign current_category = site.data.error_categories.categories | where: "slug", category_slug | first %}
        
        <!-- Authentication check wrapper -->
        <div id="auth-check-wrapper" style="display: none;">
          <div style="text-align: center; padding: 50px;">
            <h2>Access Denied</h2>
            <p>You need the "code-comprehension" role to view this page.</p>
            <button onclick="authService.login()" class="login-btn">Log In</button>
            <br><br>
            <a href="/dashboard/">‚Üê Back to Dashboard</a>
          </div>
        </div>

        <!-- Main content wrapper -->
        <div id="project-content-wrapper" style="display: none;">
          <style>
          /*
          ============================================================================
          ISOLATED ERROR CATEGORY PAGE STYLES - COMPLETELY INDEPENDENT
          ============================================================================
          
          These styles use highly specific selectors with !important declarations
          to ensure they are NOT affected by any global styles from the site.
          
          All selectors target: div#category-container.error-category-page
          This ensures complete isolation from any existing site styles.
          
          ============================================================================
          */
          
          /* Reset only for error category pages */
          div#category-container,
          div#category-container * {
              margin: 0;
              padding: 0;
              box-sizing: border-box;
          }

          /* Container - Highly specific selector - Allow growth */
          div#category-container.error-category-page {
              font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif !important;
              min-height: 100vh !important;
              padding: 40px 20px !important;
              max-width: none !important;
              width: 100% !important;
              margin: 0 auto !important;
              background: transparent !important;
              position: relative !important;
          }

          /* Category Header - Isolated - No Background */
          div#category-container.error-category-page div.category-header {
              text-align: center !important;
              margin-bottom: 50px !important;
              padding: 40px 30px !important;
              background: transparent !important;
              border-radius: 0 !important;
              color: #2c3e50 !important;
              box-shadow: none !important;
              border: none !important;
              position: relative !important;
          }

          div#category-container.error-category-page div.category-header h1 {
              font-size: 2.5rem !important;
              font-weight: 300 !important;
              margin-bottom: 20px !important;
              line-height: 1.2 !important;
              color: #2c3e50 !important;
              font-family: inherit !important;
              text-shadow: none !important;
          }

          div#category-container.error-category-page div.category-header p {
              font-size: 1.2rem !important;
              opacity: 0.8 !important;
              margin-bottom: 25px !important;
              line-height: 1.5 !important;
              color: #2c3e50 !important;
              font-family: inherit !important;
          }

          /* Back Link - Isolated */
          div#category-container.error-category-page div.category-header a.back-link {
              display: inline-block !important;
              background: {{ current_category.color }} !important;
              color: white !important;
              padding: 12px 24px !important;
              border-radius: 8px !important;
              text-decoration: none !important;
              font-weight: 500 !important;
              border: 2px solid {{ current_category.color }} !important;
              transition: all 0.3s ease !important;
              font-size: 1.1rem !important;
              margin: 25px 0 !important;
              position: relative !important;
              font-family: inherit !important;
              box-shadow: 0 2px 8px rgba(0,0,0,0.1) !important;
          }

          div#category-container.error-category-page div.category-header a.back-link:hover {
              background: {{ current_category.color_secondary }} !important;
              text-decoration: none !important;
              color: white !important;
              transform: translateY(-1px) !important;
              box-shadow: 0 4px 12px rgba(0,0,0,0.2) !important;
          }

          /* Navigation - Isolated styles */
          div#category-container.error-category-page div.category-navigation {
              display: flex !important;
              justify-content: center !important;
              gap: 15px !important;
              margin-bottom: 50px !important;
              flex-wrap: wrap !important;
              padding: 0 20px !important;
              background: transparent !important;
          }

          div#category-container.error-category-page div.category-navigation a.nav-category-btn {
              padding: 15px 55px !important;
              border: 2px solid {{ current_category.color }} !important;
              border-radius: 8px !important;
              background: white !important;
              color: {{ current_category.color }} !important;
              text-decoration: none !important;
              font-weight: 500 !important;
              transition: all 0.3s ease !important;
              font-size: 11px !important;
              white-space: nowrap !important;
              box-shadow: 0 2px 8px rgba(0,0,0,0.1) !important;
              min-height: 80px !important;
              display: flex !important;
              align-items: center !important;
              justify-content: center !important;
              text-align: center !important;
              line-height: 1.2 !important;
              font-family: inherit !important;
          }

          div#category-container.error-category-page div.category-navigation a.nav-category-btn:hover {
              background: {{ current_category.color }} !important;
              color: white !important;
              text-decoration: none !important;
              transform: translateY(-1px) !important;
          }

          div#category-container.error-category-page div.category-navigation a.nav-category-btn.active {
              background: {{ current_category.color }} !important;
              background-color: {{ current_category.color }} !important;
              color: white !important;
              box-shadow: 0 4px 15px rgba(0,0,0,0.2) !important;
              transform: translateY(-2px) !important;
              border-color: {{ current_category.color_secondary }} !important;
              border: 2px solid {{ current_category.color_secondary }} !important;
              font-weight: 600 !important;
          }
          
          /* Extra specific selector to override any inline styles */
          div#category-container.error-category-page div.category-navigation a.nav-category-btn[class*="active"] {
              background: {{ current_category.color }} !important;
              background-color: {{ current_category.color }} !important;
              color: white !important;
          }

          /* Three Column Layout - Allow columns to grow */
          div#category-container.error-category-page div.three-column-layout {
              display: grid !important;
              grid-template-columns: minmax(300px, 1fr) minmax(280px, auto) minmax(300px, 1fr) !important;
              gap: 30px !important;
              margin-top: 30px !important;
              padding: 0 10px !important;
              width: 100% !important;
              max-width: none !important;
          }

          .error-list-container {
              background: white;
              border-radius: 16px;
              box-shadow: 0 8px 30px rgba(0,0,0,0.12);
              overflow: hidden;
              border: 1px solid rgba(0,0,0,0.05);
          }

          .checkbox-column {
              background: white;
              border-radius: 16px;
              box-shadow: 0 8px 30px rgba(0,0,0,0.12);
              overflow: hidden;
              border: 1px solid rgba(0,0,0,0.05);
          }

          .checkbox-header {
              background: #2c3e50;
              color: white;
              padding: 25px 20px;
              text-align: center;
              position: relative;
          }

          .checkbox-header::before,
          .checkbox-header::after {
              content: '';
              position: absolute;
              left: 50%;
              transform: translateX(-50%);
              width: 80%;
              height: 1px;
              background: rgba(255,255,255,0.2);
          }

          .checkbox-header::before {
              top: 0;
          }

          .checkbox-header::after {
              bottom: 0;
          }

          .checkbox-header h3 {
              margin: 0;
              font-size: 1.2rem;
              padding: 15px 10px;
              line-height: 1.4;
          }

          .checkbox-list {
              padding: 25px;
              max-height: 600px;
              overflow-y: auto;
          }

          .checkbox-item {
              display: flex;
              align-items: center;
              margin-bottom: 15px;
              padding: 12px;
              border-radius: 8px;
              transition: background-color 0.2s;
          }

          .checkbox-item:hover {
              background-color: #f8f9fa;
          }

          .checkbox-item input[type="checkbox"] {
              margin-right: 10px;
              transform: scale(1.2);
          }

          .checkbox-item label {
              cursor: pointer;
              color: #2c3e50;
              font-weight: 500;
              padding: 2px 8px;
              line-height: 1.4;
          }

          .prompt-generation-column {
              background: white;
              border-radius: 16px;
              box-shadow: 0 8px 30px rgba(0,0,0,0.12);
              overflow: hidden;
              border: 1px solid rgba(0,0,0,0.05);
          }

          .prompt-header {
              background: #27ae60;
              color: white;
              padding: 25px 20px;
              text-align: center;
              position: relative;
          }

          .prompt-header::before,
          .prompt-header::after {
              content: '';
              position: absolute;
              left: 50%;
              transform: translateX(-50%);
              width: 80%;
              height: 1px;
              background: rgba(255,255,255,0.2);
          }

          .prompt-header::before {
              top: 0;
          }

          .prompt-header::after {
              bottom: 0;
          }

          .prompt-header h3 {
              margin: 0;
              font-size: 1.2rem;
              padding: 15px 15px;
              line-height: 1.4;
          }

          .prompt-content {
              padding: 25px;
          }

          .prompt-textarea {
              width: 100%;
              min-height: 400px;
              padding: 20px;
              border: 2px solid #bdc3c7;
              border-radius: 10px;
              font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
              font-size: 13px;
              line-height: 1.5;
              resize: vertical;
              background: white;
              color: #2c3e50;
          }

          .prompt-textarea:focus {
              outline: none;
              border-color: #27ae60;
          }

          .prompt-actions {
              margin-top: 25px;
              display: flex;
              gap: 15px;
              flex-wrap: wrap;
          }

          .generate-prompt-btn, .copy-prompt-btn, .download-prompt-btn {
              padding: 12px 24px;
              border: none;
              border-radius: 8px;
              font-weight: 500;
              cursor: pointer;
              transition: all 0.3s ease;
              font-size: 14px;
              display: flex;
              align-items: center;
              gap: 10px;
              box-shadow: 0 2px 8px rgba(0,0,0,0.1);
          }

          .generate-prompt-btn {
              background: #27ae60;
              color: white;
          }

          .generate-prompt-btn:hover {
              background: #229954;
              transform: translateY(-1px);
          }

          .copy-prompt-btn, .download-prompt-btn {
              background: #3498db;
              color: white;
          }

          .copy-prompt-btn:hover, .download-prompt-btn:hover {
              background: #2980b9;
              transform: translateY(-1px);
          }

          .copy-prompt-btn:disabled, .download-prompt-btn:disabled {
              background: #bdc3c7;
              cursor: not-allowed;
              transform: none;
          }

          .error-list-header {
              background: #2c3e50;
              color: white;
              padding: 25px 20px;
              text-align: center;
              position: relative;
          }

          .error-list-header::before,
          .error-list-header::after {
              content: '';
              position: absolute;
              left: 50%;
              transform: translateX(-50%);
              width: 80%;
              height: 1px;
              background: rgba(255,255,255,0.2);
          }

          .error-list-header::before {
              top: 0;
          }

          .error-list-header::after {
              bottom: 0;
          }

          .error-list-header h2 {
              margin: 0 0 15px 0;
              font-size: 1.5rem;
              padding: 15px 10px;
              line-height: 1.3;
          }

          .error-count {
              background: rgba(255,255,255,0.2);
              padding: 8px 18px;
              border-radius: 20px;
              font-size: 0.9rem;
              display: inline-block;
              margin-top: 5px;
          }

          .error-list {
              padding: 0;
              margin: 0;
              list-style: none;
          }

          /* Error Items - Isolated styling */
          div#category-container.error-category-page .error-list .error-item {
              padding: 20px 30px !important;
              border-bottom: 2px solid #bdc3c7 !important;
              transition: background-color 0.3s ease !important;
              text-align: center !important;
              background: white !important;
          }

          div#category-container.error-category-page .error-list .error-item:hover {
              background: #f8f9fa !important;
          }

          div#category-container.error-category-page .error-list .error-item:last-child {
              border-bottom: 2px solid #bdc3c7 !important;
          }

          /* Error ID - Isolated styling */
          div#category-container.error-category-page .error-list .error-item .error-id {
              font-weight: 600 !important;
              color: {{ current_category.color }} !important;
              font-size: 1.2rem !important;
              margin: 0 !important;
              text-align: center !important;
              font-family: inherit !important;
          }

          .error-description {
              color: #2c3e50;
              line-height: 1.6;
              margin-bottom: 25px;
              font-size: 16px;
          }

          .code-sections {
              display: grid;
              grid-template-columns: 1fr 1fr;
              gap: 25px;
              margin-bottom: 25px;
          }

          .code-section {
              background: #f8f9fa;
              border-radius: 10px;
              overflow: hidden;
              border: 1px solid #e9ecef;
              box-shadow: 0 2px 8px rgba(0,0,0,0.05);
          }

          .code-section h4 {
              background: #2c3e50;
              color: white;
              padding: 18px 25px;
              margin: 0;
              font-size: 14px;
              font-weight: 600;
              line-height: 1.4;
              letter-spacing: 0.5px;
          }

          .code-content {
              padding: 20px;
              font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
              font-size: 13px;
              line-height: 1.5;
              white-space: pre-wrap;
              word-break: break-word;
              max-height: 300px;
              overflow-y: auto;
              background: white;
          }

          .error-meta {
              display: flex;
              gap: 25px;
              font-size: 0.9rem;
              color: #7f8c8d;
              margin-top: 20px;
              flex-wrap: wrap;
          }

          .error-meta span {
              display: flex;
              align-items: center;
              gap: 5px;
          }

          .no-errors {
              text-align: center;
              padding: 60px 20px;
              color: #7f8c8d;
              font-style: italic;
          }

          .no-errors h3 {
              color: #27ae60;
              margin-bottom: 15px;
              padding: 0 10px;
              line-height: 1.4;
          }

          .no-errors p {
              padding: 0 15px 25px 15px;
              line-height: 1.5;
              margin-bottom: 10px;
          }

          @media (max-width: 1200px) {
              div#category-container.error-category-page div.three-column-layout {
                  grid-template-columns: 1fr !important;
                  gap: 15px !important;
              }
          }

          @media (max-width: 768px) {
              .category-header h1 {
                  font-size: 1.8rem;
              }
              
              .code-sections {
                  grid-template-columns: 1fr;
                  gap: 15px;
              }
              
              .error-meta {
                  flex-direction: column;
                  gap: 8px;
              }
              
              .error-item {
                  padding: 20px;
              }
              
              .category-navigation {
                  gap: 5px;
              }
              
              .nav-category-btn {
                  font-size: 10px;
                  padding: 10px 35px;
                  min-height: 60px;
              }

              .prompt-textarea {
                  min-height: 300px;
              }

              .prompt-actions {
                  flex-direction: column;
                  gap: 8px;
              }

              .generate-prompt-btn, .copy-prompt-btn, .download-prompt-btn {
                  width: 100%;
                  justify-content: center;
              }
          }
          </style>

          <div id="category-container" class="error-category-page">
              <!-- Category Navigation -->
              <div class="category-navigation">
                  {% for category in site.data.error_categories.categories %}
                  <a href="{{ category.permalink }}" 
                     class="nav-category-btn{% if category.slug == category_slug %} active{% endif %}"
                     data-category-color="{{ category.color }}"
                     data-category-secondary="{{ category.color_secondary }}"
                     style="{% if category.slug == category_slug %}background: {{ category.color }} !important; color: white !important; border-color: {{ category.color_secondary }} !important;{% else %}border-color: {{ category.color }}; color: {{ category.color }};{% endif %}">
                      {{ category.name }}
                  </a>
                  {% endfor %}
              </div>

              <div class="category-header">
                  <h1>{{ current_category.name }}</h1>
                  <p>{{ current_category.description }}</p>
                  <div style="margin-top: 25px;">
                      <button id="backToAnalysisBtn" class="back-link" style="border: none; cursor: pointer;">‚Üê Back to Analysis</button>
                  </div>
              </div>

              <div class="three-column-layout">
                  <!-- Left Column: Error List -->
                  <div class="error-list-container">
                      <div class="error-list-header">
                          <div>&nbsp;</div>
                          <h2> Annotated Errors </h2>
                          <div>&nbsp;</div>
                          <div class="error-count" id="errorCount">0 errors found</div>
                      </div>
                      
                      <div id="errorListContent">
                          <!-- Error list will be populated here -->
                      </div>
                  </div>

                  <!-- Middle Column: Error Checkboxes -->
                  <div class="checkbox-column">
                      <div class="checkbox-header">
                          <div>&nbsp;</div>
                          <h3> Select Errors </h3>
                          <div>&nbsp;</div>
                      </div>
                      <div class="checkbox-list" id="errorCheckboxes">
                          <!-- Error checkboxes will be populated here -->
                      </div>
                  </div>

                  <!-- Right Column: Prompt Generation -->
                  <div class="prompt-generation-column">
                      <div class="prompt-header">
                          <div>&nbsp;</div>
                          <h3> Generalizations </h3>
                          <div>&nbsp;</div>
                      </div>
                      <div class="prompt-content">
                          <textarea id="promptTextarea" class="prompt-textarea" placeholder="Analysis of selected errors will appear here...

Select errors from the middle column to generate insights about error patterns and tendencies in this category."></textarea>
                          <div class="prompt-actions">
                              <button id="generatePromptBtn" class="generate-prompt-btn">üöÄ Generate Enhanced Prompt</button>
                              <button id="copyPromptBtn" class="copy-prompt-btn" disabled>üìã Copy Prompt</button>
                              <button id="downloadPromptBtn" class="download-prompt-btn" disabled>üíæ Download Prompt</button>
                          </div>
                      </div>
                  </div>
              </div>
          </div>

          <script>
          console.log('Error Category {{ current_category.number }} - Script loaded');

          class ErrorCategoryViewer {
              constructor() {
                  this.categoryNumber = {{ current_category.number }};
                  this.categorySlug = '{{ current_category.slug }}';
                  this.categoryName = '{{ current_category.name }}';
                  this.annotations = {};
                  this.csvData = [];
                  this.categoryErrors = [];
                  this.selectedErrors = new Set();
                  this.existingPrompt = `You are an assistant specialized in refactoring code using for novices. Your goal is to make code more **readable**, **understandable**, and **maintainable** for novices.

# Refactoring Evaluation
You must first **evaluate whether the code needs refactoring**.
- If the code is **already clean and well-structured**, return it unchanged.
- Apply small improvements (e.g., renaming, adding comments) if they enhance clarity without altering semantics.

# Guide for refactoring
Look for:
- Long or deeply nested functions
- Multiple concerns per method
- Poor or inconsistent naming
- Overuse of control flow or asynchronous patterns

When refactoring:
Do this:
- Break logic into focused, small units
- Preserve clear, sequential flow
- Use self-descriptive names
- Reduce nesting and deep control structures

Don't do this:
If a function is not returning anything, it's not correct refactoring. Do not do it.
Example: 
Wrong Code
What you should do:
Correct Code
-
-


Now for the given code snippet, do Code Refactoring using the above guideline:

Code script:
{code}

Write the refactored code output in the same code language and format.
Note the primary method in the code that a user needs to call.
**Do not write the reasoning and explanation.**

Return in the following JSON format:

{
  "output": {
    "refactored_code": "[refactored code here]",
    "primary_method": "[primary method name here]"
  }
}`;
                  
                  this.initializeAsync();
              }

              async initializeAsync() {
                  await this.loadData();
              }
              
              async loadData() {
                  try {
                      // Try to load from annotated-code.json file first
                      await this.loadFromJsonFile();
                      
                      // Fallback to localStorage if no file data
                      if (Object.keys(this.annotations).length === 0) {
                          const storedAnnotations = localStorage.getItem('errorAnnotations');
                          const storedCsvData = localStorage.getItem('csvData');
                          
                          if (storedAnnotations) {
                              this.annotations = JSON.parse(storedAnnotations);
                          }
                          
                          if (storedCsvData) {
                              this.csvData = JSON.parse(storedCsvData);
                          }
                      }
                      
                      this.displayErrors();
                  } catch (error) {
                      console.error('Error loading category data:', error);
                      this.showNoData();
                  }
              }

              async loadFromJsonFile() {
                  try {
                      // Try to fetch the annotated-code.json file
                      const response = await fetch('/annotated-code.json');
                      if (response.ok) {
                          const jsonData = await response.json();
                          console.log('Loaded annotated-code.json:', jsonData);
                          
                          // Extract annotations and CSV data from the JSON structure
                          if (jsonData.annotations) {
                              this.annotations = jsonData.annotations;
                          }
                          
                          if (jsonData.csvData) {
                              this.csvData = jsonData.csvData;
                          }
                          
                          // Also check for entry_tags format (alternative structure)
                          if (jsonData.entry_tags) {
                              this.annotations = jsonData.entry_tags;
                          }
                          
                          console.log('Processed annotations:', Object.keys(this.annotations).length, 'entries');
                          console.log('Processed CSV data:', this.csvData.length, 'entries');
                      } else {
                          console.log('annotated-code.json not found, falling back to localStorage');
                      }
                  } catch (error) {
                      console.log('Could not load annotated-code.json:', error.message);
                  }
              }
              
              displayErrors() {
                  console.log('Displaying errors for category:', this.categoryName);
                  console.log('Available annotations:', Object.keys(this.annotations).length);
                  console.log('Available CSV data:', this.csvData.length);
                  
                  // Find all errors in this category
                  this.categoryErrors = [];
                  
                  Object.entries(this.annotations).forEach(([entryId, tags]) => {
                      // Handle both array and string tag formats
                      const tagArray = Array.isArray(tags) ? tags : [tags];
                      
                      if (tagArray.includes(this.categoryName)) {
                          console.log('Found matching entry:', entryId, 'with tags:', tagArray);
                          
                          // Find the corresponding CSV entry
                          const csvEntry = this.csvData.find(entry => 
                              (entry.task_id && entry.task_id === entryId) || 
                              entryId.includes(entry.task_id) ||
                              (entry.id && entry.id === entryId)
                          );
                          
                          if (csvEntry) {
                              this.categoryErrors.push({
                                  id: entryId,
                                  entry: csvEntry,
                                  tags: tagArray
                              });
                          } else {
                              console.log('No CSV entry found for:', entryId);
                          }
                      }
                  });
                  
                  console.log('Category errors found:', this.categoryErrors.length);
                  
                  // Update error count
                  document.getElementById('errorCount').textContent = `${this.categoryErrors.length} errors found`;
                  
                  // Display errors and checkboxes
                  if (this.categoryErrors.length === 0) {
                      this.showNoErrors();
                      this.showNoCheckboxes();
                  } else {
                      this.showErrorList(this.categoryErrors);
                      this.showErrorCheckboxes(this.categoryErrors);
                  }
              }
              
              showErrorList(errors) {
                  const container = document.getElementById('errorListContent');
                  
                  if (errors.length === 0) {
                      this.showNoErrors();
                      return;
                  }
                  
                  let html = '<ul class="error-list">';
                  
                  errors.forEach((error, index) => {
                      const description = error.entry.text || error.entry.task_description || error.entry.description || 'No description available';
                      const originalCode = error.entry['original code'] || error.entry.original_code || error.entry.code || 'No original code available';
                      const refactoredCode = this.extractRefactoredCode(error.entry.refactored_code) || 'No refactored code available';
                      const originalResult = error.entry.original_test_result || error.entry.original_result || 'No result';
                      const refactoredResult = error.entry.refactored_test_result || error.entry.refactored_result || 'No result';
                      
                      html += `
                          <li class="error-item">
                              <div class="error-id">Error #${index + 1}: ${error.entry.task_id || 'Unknown ID'}</div>
                              <div class="error-description">${description}</div>
                              
                              <div class="code-sections">
                                  <div class="code-section">
                                      <h4>Original Code (Contains Error)</h4>
                                      <div class="code-content">${originalCode}</div>
                                  </div>
                                  <div class="code-section">
                                      <h4>Refactored Code (Fixed)</h4>
                                      <div class="code-content">${refactoredCode}</div>
                                  </div>
                              </div>
                              
                              <div class="error-meta">
                                  <span>üìù Task: ${error.entry.task_id || 'Unknown'}</span>
                                  <span>üêõ Error Type: ${this.categoryName}</span>
                                  <span>‚úÖ Test Result: ${originalResult === 'TRUE' ? 'Pass' : 'Fail'}</span>
                              </div>
                          </li>
                      `;
                  });
                  
                  html += '</ul>';
                  container.innerHTML = html;
              }
              
              extractRefactoredCode(refactoredCodeField) {
                  if (!refactoredCodeField) return 'No refactored code available';
                  
                  // Check if it starts with ```json (from the CSV)
                  if (refactoredCodeField.trim().startsWith('```json')) {
                      try {
                          // Extract JSON content between ```json and ```
                          const jsonMatch = refactoredCodeField.match(/```json\s*\n([\s\S]*?)\n```/);
                          if (jsonMatch) {
                              const jsonStr = jsonMatch[1];
                              // Parse the JSON and extract the refactored_code
                              const parsed = JSON.parse(jsonStr);
                              if (parsed.output && parsed.output.refactored_code) {
                                  // Unescape the code
                                  return parsed.output.refactored_code.replace(/\\n/g, '\n').replace(/\\"/g, '"');
                              }
                          }
                      } catch (e) {
                          console.warn('Failed to parse JSON-wrapped refactored code:', e);
                      }
                  }
                  
                  // Return as-is if not JSON-wrapped
                  return refactoredCodeField;
              }
              
              showErrorCheckboxes(errors) {
                  const container = document.getElementById('errorCheckboxes');
                  
                  if (errors.length === 0) {
                      container.innerHTML = `
                          <div style="text-align: center; color: #7f8c8d; font-style: italic; padding: 20px;">
                              No errors found in this category
                          </div>
                      `;
                      return;
                  }
                  
                  let html = '';
                  errors.forEach((error, index) => {
                      const errorNumber = index + 1;
                      const description = error.entry.text || error.entry.task_description || error.entry.description || 'No description available';
                      // Truncate description for display
                      const shortDescription = description.length > 40 ? description.substring(0, 40) + '...' : description;
                      
                      html += `
                          <div class="checkbox-item">
                              <input type="checkbox" id="error_${errorNumber}" value="${errorNumber}" 
                                     onchange="errorCategoryViewer.onCheckboxChange(${errorNumber})">
                              <label for="error_${errorNumber}" title="${description}">
                                  Error #${errorNumber}: ${shortDescription}
                              </label>
                          </div>
                      `;
                  });
                  
                  container.innerHTML = html;
              }

              showNoCheckboxes() {
                  const container = document.getElementById('errorCheckboxes');
                  container.innerHTML = `
                      <div style="text-align: center; color: #7f8c8d; font-style: italic; padding: 20px;">
                          No errors found in this category
                      </div>
                  `;
              }

              onCheckboxChange(errorNumber) {
                  if (document.getElementById(`error_${errorNumber}`).checked) {
                      this.selectedErrors.add(errorNumber);
                  } else {
                      this.selectedErrors.delete(errorNumber);
                  }
                  this.updateGeneralization();
              }

              updateGeneralization() {
                  const textarea = document.getElementById('promptTextarea');
                  const copyBtn = document.getElementById('copyPromptBtn');
                  const downloadBtn = document.getElementById('downloadPromptBtn');
                  
                  if (this.selectedErrors.size === 0) {
                      textarea.value = `Analysis of selected errors will appear here...

Select errors from the middle column to generate insights about error patterns and tendencies in this category.`;
                      // Disable buttons when no errors selected
                      copyBtn.disabled = true;
                      downloadBtn.disabled = true;
                      return;
                  }

                  // Get selected error data
                  const selectedErrorData = Array.from(this.selectedErrors).map(errorNum => {
                      const errorIndex = errorNum - 1;
                      return this.categoryErrors[errorIndex];
                  });

                  // Generate generalization
                  const generalization = this.generateGeneralization(selectedErrorData);
                  textarea.value = generalization;
                  
                  // Enable buttons since we have content
                  copyBtn.disabled = false;
                  downloadBtn.disabled = false;
              }

              generateGeneralization(selectedErrors) {
                  // Create the new generalization section
                  let generalizationSection = '\ngeneralization ```\n';
                  
                  selectedErrors.forEach(error => {
                      const originalCode = error.entry['original code'] || 'No original code available';
                      const refactoredCode = this.extractRefactoredCode(error.entry.refactored_code) || 'No refactored code available';
                      
                      generalizationSection += `<original code>\n${originalCode}\n\n<refactored code>\n${refactoredCode}\n\n`;
                  });

                  // Add common patterns analysis
                  const commonPatterns = this.analyzeCommonPatterns(selectedErrors);
                  generalizationSection += `<what these have in common>\n${commonPatterns}\n```\n\n`;

                  // Get all annotation data for the existing analysis section
                  const totalAnnotated = Object.keys(this.annotations).length;
                  const analysis = this.analyzeAnnotationPatterns();

                  // Create the full prompt with existing structure
                  return `${this.existingPrompt}

${generalizationSection}## CRITICAL ERROR PREVENTION ANALYSIS

Based on analysis of ${totalAnnotated} annotated error cases, the following patterns have been identified to help prevent common LLM mistakes:

### Error Patterns Identified from Annotations:

${this.generateErrorPatternSections(analysis)}

### MANDATORY REQUIREMENTS:
1. **Function Signatures**: Always verify the exact number and names of parameters required
2. **Variable Names**: Ensure all variables are properly defined before use  
3. **Return Types**: Match expected return formats exactly
4. **Test Compatibility**: Code must pass the provided test cases without modification
5. **Syntax Validation**: Check for proper Python syntax, indentation, and brackets

### QUALITY CHECKLIST:
- [ ] Function signature matches test calls exactly
- [ ] All variables are defined before use
- [ ] Return format matches expected output
- [ ] No syntax errors or typos
- [ ] Logic handles edge cases properly

Remember: These ${totalAnnotated} errors were identified through careful analysis. Focus on correctness over complexity.`;
              }

              analyzeCommonPatterns(selectedErrors) {
                  const patterns = [];
                  
                  // Analyze common issues
                  const tags = selectedErrors.flatMap(error => error.tags);
                  const tagCounts = {};
                  tags.forEach(tag => {
                      tagCounts[tag] = (tagCounts[tag] || 0) + 1;
                  });

                  const commonTags = Object.entries(tagCounts)
                      .filter(([tag, count]) => count > 1)
                      .map(([tag, count]) => `${tag} (${count} occurrences)`);

                  if (commonTags.length > 0) {
                      patterns.push(`Common error types: ${commonTags.join(', ')}`);
                  }

                  // Add category-specific analysis
                  patterns.push(`All errors belong to the "${this.categoryName}" category`);
                  patterns.push(`Selected ${selectedErrors.length} errors for analysis`);

                  return patterns.join('\n');
              }

              analyzeAnnotationPatterns() {
                  const tagCounts = {};
                  Object.values(this.annotations).forEach(tags => {
                      tags.forEach(tag => {
                          tagCounts[tag] = (tagCounts[tag] || 0) + 1;
                      });
                  });
                  
                  const errorTypes = {};
                  Object.values(this.annotations).forEach(tags => {
                      tags.forEach(tag => {
                          if (tag.toLowerCase().includes('signature') || tag.toLowerCase().includes('argument')) {
                              errorTypes['Function Signature Issues'] = (errorTypes['Function Signature Issues'] || 0) + 1;
                          } else if (tag.toLowerCase().includes('logical') || tag.toLowerCase().includes('algorithm')) {
                              errorTypes['Logic/Algorithm Errors'] = (errorTypes['Logic/Algorithm Errors'] || 0) + 1;
                          } else if (tag.toLowerCase().includes('syntax') || tag.toLowerCase().includes('environment')) {
                              errorTypes['Syntax/Environment Issues'] = (errorTypes['Syntax/Environment Issues'] || 0) + 1;
                          } else {
                              errorTypes['Other Issues'] = (errorTypes['Other Issues'] || 0) + 1;
                          }
                      });
                  });
                  
                  return { tagCounts, errorTypes };
              }

              generateErrorPatternSections(analysis) {
                  let sections = '';
                  let count = 1;
                  
                  Object.entries(analysis.errorTypes).forEach(([category, occurrences]) => {
                      sections += `\n${count}. **${category}** - ${this.getCategoryDescription(category)}
   Frequency: ${occurrences} instances identified
   Focus Area: ${this.getCategoryFocusArea(category)}\n`;
                      count++;
                  });
                  
                  const topTags = Object.entries(analysis.tagCounts)
                      .sort(([,a], [,b]) => b - a)
                      .slice(0, 5);
                      
                  if (topTags.length > 0) {
                      sections += `\n### Most Common Annotation Tags:`;
                      topTags.forEach(([tag, count]) => {
                          sections += `\n‚Ä¢ ${tag}: ${count} occurrences`;
                      });
                  }
                  
                  return sections;
              }

              getCategoryDescription(category) {
                  const descriptions = {
                      'Function Signature Issues': 'Wrong number/type of function parameters',
                      'Logic/Algorithm Errors': 'Incorrect implementation of algorithm logic',
                      'Syntax/Environment Issues': 'Code syntax and environment setup problems',
                      'Other Issues': 'Various other coding problems identified'
                  };
                  return descriptions[category] || 'Code execution issues';
              }

              getCategoryFocusArea(category) {
                  const focusAreas = {
                      'Function Signature Issues': 'Parameter validation and function call matching',
                      'Logic/Algorithm Errors': 'Algorithm correctness and edge case handling',
                      'Syntax/Environment Issues': 'Python syntax rules and environment setup',
                      'Other Issues': 'General code quality and best practices'
                  };
                  return focusAreas[category] || 'Code quality improvement';
              }

              generateEnhancedPrompt() {
                  if (this.selectedErrors.size === 0) {
                      alert('Please select at least one error to generate an enhanced prompt.');
                      return;
                  }

                  // The prompt is already generated in the textarea via updateGeneralization
                  // Just enable the copy and download buttons
                  document.getElementById('copyPromptBtn').disabled = false;
                  document.getElementById('downloadPromptBtn').disabled = false;
                  
                  // Show success message
                  const button = document.getElementById('generatePromptBtn');
                  const originalText = button.innerHTML;
                  button.innerHTML = '‚úÖ Prompt Generated!';
                  button.style.background = '#27ae60';
                  
                  setTimeout(() => {
                      button.innerHTML = originalText;
                      button.style.background = '#27ae60';
                  }, 2000);
              }

              copyPromptToClipboard() {
                  const textarea = document.getElementById('promptTextarea');
                  const promptText = textarea.value;
                  
                  if (!promptText || promptText.includes('Analysis of selected errors will appear here')) {
                      alert('Please generate a prompt first by selecting errors and clicking "Generate Enhanced Prompt".');
                      return;
                  }

                  navigator.clipboard.writeText(promptText).then(() => {
                      const button = document.getElementById('copyPromptBtn');
                      const originalText = button.innerHTML;
                      button.innerHTML = '‚úÖ Copied!';
                      
                      setTimeout(() => {
                          button.innerHTML = originalText;
                      }, 2000);
                  }).catch(err => {
                      console.error('Failed to copy prompt: ', err);
                      alert('Failed to copy prompt to clipboard. Please try selecting and copying manually.');
                  });
              }

              downloadPrompt() {
                  const textarea = document.getElementById('promptTextarea');
                  const promptText = textarea.value;
                  
                  if (!promptText || promptText.includes('Analysis of selected errors will appear here')) {
                      alert('Please generate a prompt first by selecting errors and clicking "Generate Enhanced Prompt".');
                      return;
                  }

                  const blob = new Blob([promptText], { type: 'text/plain' });
                  const url = window.URL.createObjectURL(blob);
                  const link = document.createElement('a');
                  link.href = url;
                  link.download = `enhanced-prompt-category-${this.categoryNumber}-${new Date().toISOString().split('T')[0]}.txt`;
                  
                  document.body.appendChild(link);
                  link.click();
                  document.body.removeChild(link);
                  
                  window.URL.revokeObjectURL(url);
                  
                  const button = document.getElementById('downloadPromptBtn');
                  const originalText = button.innerHTML;
                  button.innerHTML = '‚úÖ Downloaded!';
                  
                  setTimeout(() => {
                      button.innerHTML = originalText;
                  }, 2000);
              }

              showNoErrors() {
                  const container = document.getElementById('errorListContent');
                  container.innerHTML = `
                      <div class="no-errors">
                          <h3>üéâ No Errors Found!</h3>
                          <p>There are no annotated errors in the "${this.categoryName}" category.</p>
                          <p>This could mean either no errors of this type occurred in the dataset, or they haven't been annotated yet.</p>
                          <div style="margin-top: 15px;">
                              <a href="/error-annotator/" style="color: {{ current_category.color }}; text-decoration: none; font-weight: 500;">‚Üê Return to Error Annotator</a>
                          </div>
                      </div>
                  `;
              }
              
              showNoData() {
                  const container = document.getElementById('errorListContent');
                  container.innerHTML = `
                      <div class="no-errors">
                          <h3>‚ùå No Data Available</h3>
                          <p>No annotation data found. Please return to the Error Annotator and load a CSV file first.</p>
                          <div style="margin-top: 15px;">
                              <a href="/error-annotator/" style="color: {{ current_category.color }}; text-decoration: none; font-weight: 500;">‚Üê Return to Error Annotator</a>
                          </div>
                      </div>
                  `;
              }

              /**
               * Navigate back to analysis page with current data preserved
               */
              backToAnalysis() {
                  console.log('üîÑ backToAnalysis() method called');
                  
                  try {
                      console.log('üìä Back to Analysis - checking data:', {
                          hasCSVData: !!this.csvData,
                          csvDataEntries: this.csvData ? this.csvData.length : 0,
                          hasAnnotations: !!this.annotations,
                          annotationEntries: this.annotations ? Object.keys(this.annotations).length : 0
                      });
                      
                      // Store all current data in localStorage for the finished-annotating page
                      if (this.csvData && this.csvData.length > 0) {
                          localStorage.setItem('csvData', JSON.stringify(this.csvData));
                          console.log('‚úÖ Stored CSV data:', this.csvData.length, 'entries');
                      } else {
                          console.warn('‚ö†Ô∏è No CSV data to store');
                      }
                      
                      if (this.annotations && Object.keys(this.annotations).length > 0) {
                          localStorage.setItem('errorAnnotations', JSON.stringify(this.annotations));
                          console.log('‚úÖ Stored annotations:', Object.keys(this.annotations).length, 'entries');
                      } else {
                          console.warn('‚ö†Ô∏è No annotations to store');
                      }
                      
                      // Also ensure we store any CSV file metadata we might have from the JSON file
                      const csvFileInfo = {
                          name: 'annotated-code.json', // Since we're loading from JSON file
                          source: 'json_file',
                          loadedAt: new Date().toISOString(),
                          totalEntries: this.csvData ? this.csvData.length : 0
                      };
                      localStorage.setItem('currentCSVFile', JSON.stringify(csvFileInfo));
                      console.log('‚úÖ Stored CSV file info:', csvFileInfo);
                      
                      // Navigate to finished annotating page
                      console.log('üöÄ Navigating to finished-annotating page...');
                      setTimeout(() => {
                          window.location.href = '/finished-annotating/';
                      }, 100); // Small delay to ensure storage completes
                      
                  } catch (error) {
                      console.error('‚ùå Error storing data for analysis page:', error);
                      alert('Error saving data. Redirecting to analysis page anyway.');
                      // Fallback to direct navigation
                      window.location.href = '/finished-annotating/';
                  }
              }

          }

          // Global variable for error category viewer
          let errorCategoryViewer;

          // Initialize when page loads
          document.addEventListener('DOMContentLoaded', () => {
              errorCategoryViewer = new ErrorCategoryViewer();
              
              // Add event listeners for prompt buttons
              document.getElementById('generatePromptBtn').addEventListener('click', () => {
                  errorCategoryViewer.generateEnhancedPrompt();
              });
              
              document.getElementById('copyPromptBtn').addEventListener('click', () => {
                  errorCategoryViewer.copyPromptToClipboard();
              });
              
              document.getElementById('downloadPromptBtn').addEventListener('click', () => {
                  errorCategoryViewer.downloadPrompt();
              });
              
              // Back to analysis
              const backToAnalysisBtn = document.getElementById('backToAnalysisBtn');
              if (backToAnalysisBtn) {
                  backToAnalysisBtn.addEventListener('click', (e) => {
                      console.log('Back to Analysis button clicked');
                      e.preventDefault(); // Prevent any default behavior
                      try {
                          errorCategoryViewer.backToAnalysis();
                      } catch (error) {
                          console.error('Error in backToAnalysis:', error);
                          // Fallback navigation
                          window.location.href = '/finished-annotating/';
                      }
                  });
                  console.log('Back to Analysis button event listener added');
              } else {
                  console.error('Back to Analysis button not found');
              }
          });
          </script>

        </div>

        <!-- Authentication script -->
        <script>
        console.log('Error Category {{ current_category.number }} - Auth script loaded');

        document.addEventListener('authReady', () => {
            console.log('Error Category {{ current_category.number }} - authReady event fired');
            if (window.authService.isAuthenticated) {
                const user = window.authService.user;
                
                // Check user roles in multiple possible locations
                const customRoles = user['https://carsontkempf.github.io/roles'] || [];
                const auth0Roles = user['https://auth0.com/roles'] || [];
                const appMetadataRoles = user.app_metadata?.roles || [];
                const userMetadataRoles = user.user_metadata?.roles || [];
                
                // Check additional possible role locations
                const rolesArray = user.roles || [];
                const authorizationRoles = user.authorization?.roles || [];
                const orgRoles = user['org_roles'] || [];
                const realmRoles = user['realm_roles'] || [];
                
                // Combine all possible role sources
                const allRoles = [...customRoles, ...auth0Roles, ...appMetadataRoles, ...userMetadataRoles, ...rolesArray, ...authorizationRoles, ...orgRoles, ...realmRoles];
                
                const hasAdminRole = allRoles.includes('admin');
                const hasCodeComprehensionRole = allRoles.includes('code-comprehension') || 
                                                allRoles.includes('Code-Comprehension-Project') || 
                                                allRoles.includes('rol_XUUh9ZOhirY2yCQQ');
                const isSiteOwner = user.email === 'ctkfdp@umsystem.edu';
                
                // Check if user has any of the required permissions
                if (hasAdminRole || hasCodeComprehensionRole || isSiteOwner) {
                    document.getElementById('project-content-wrapper').style.display = 'block';
                } else {
                    document.getElementById('auth-check-wrapper').style.display = 'block';
                }
            } else {
                console.log('Error Category {{ current_category.number }} - User not authenticated');
                document.getElementById('auth-check-wrapper').style.display = 'block';
            }
        });

        // If auth service isn't ready after 5 seconds, show access denied
        setTimeout(() => {
            if (!window.authService || !window.authService.isAuthenticated) {
                document.getElementById('auth-check-wrapper').style.display = 'block';
            }
        }, 5000);
        </script>