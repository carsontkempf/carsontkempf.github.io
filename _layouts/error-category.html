---
layout: default
---
        <!-- Extract category slug from page URL -->
        {% assign url_parts = page.url | split: '/' %}
        {% assign category_slug = url_parts[-2] %}
        
        <!-- Find the category data -->
        {% assign current_category = site.data.error_categories.categories | where: "slug", category_slug | first %}
        
        <!-- Authentication check wrapper -->
        <div id="auth-check-wrapper" style="display: none;">
          <div style="text-align: center; padding: 50px;">
            <h2>Access Denied</h2>
            <p>You need the "code-comprehension" role to view this page.</p>
            <button onclick="authService.login()" class="login-btn">Log In</button>
            <br><br>
            <a href="/dashboard/">‚Üê Back to Dashboard</a>
          </div>
        </div>

        <!-- Main content wrapper -->
        <div id="project-content-wrapper" style="display: none;">
          <style>
          /*
          ============================================================================
          ISOLATED ERROR CATEGORY PAGE STYLES - COMPLETELY INDEPENDENT
          ============================================================================
          
          These styles use highly specific selectors with !important declarations
          to ensure they are NOT affected by any global styles from the site.
          
          All selectors target: div#category-container.error-category-page
          This ensures complete isolation from any existing site styles.
          
          ============================================================================
          */
          
          /* Reset only for error category pages */
          div#category-container,
          div#category-container * {
              margin: 0;
              padding: 0;
              box-sizing: border-box;
          }

          /* Container - Highly specific selector - Allow growth */
          div#category-container.error-category-page {
              font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif !important;
              min-height: 100vh !important;
              padding: 40px 20px !important;
              max-width: none !important;
              width: 100% !important;
              margin: 0 auto !important;
              background: transparent !important;
              position: relative !important;
          }

          /* Category Header - Isolated - No Background */
          div#category-container.error-category-page div.category-header {
              text-align: center !important;
              margin-bottom: 50px !important;
              padding: 40px 30px !important;
              background: transparent !important;
              border-radius: 0 !important;
              color: #2c3e50 !important;
              box-shadow: none !important;
              border: none !important;
              position: relative !important;
          }

          div#category-container.error-category-page div.category-header h1 {
              font-size: 2.5rem !important;
              font-weight: 300 !important;
              margin-bottom: 20px !important;
              line-height: 1.2 !important;
              color: #2c3e50 !important;
              font-family: inherit !important;
              text-shadow: none !important;
          }

          div#category-container.error-category-page div.category-header p {
              font-size: 1.2rem !important;
              opacity: 0.8 !important;
              margin-bottom: 25px !important;
              line-height: 1.5 !important;
              color: #2c3e50 !important;
              font-family: inherit !important;
          }

          /* Back Link - Isolated */
          div#category-container.error-category-page div.category-header a.back-link {
              display: inline-block !important;
              background: {{ current_category.color }} !important;
              color: white !important;
              padding: 12px 24px !important;
              border-radius: 8px !important;
              text-decoration: none !important;
              font-weight: 500 !important;
              border: 2px solid {{ current_category.color }} !important;
              transition: all 0.3s ease !important;
              font-size: 1.1rem !important;
              margin: 25px 0 !important;
              position: relative !important;
              font-family: inherit !important;
              box-shadow: 0 2px 8px rgba(0,0,0,0.1) !important;
          }

          div#category-container.error-category-page div.category-header a.back-link:hover {
              background: {{ current_category.color_secondary }} !important;
              text-decoration: none !important;
              color: white !important;
              transform: translateY(-1px) !important;
              box-shadow: 0 4px 12px rgba(0,0,0,0.2) !important;
          }

          /* Navigation - Isolated styles */
          div#category-container.error-category-page div.category-navigation {
              display: flex !important;
              justify-content: center !important;
              gap: 15px !important;
              margin-bottom: 50px !important;
              flex-wrap: wrap !important;
              padding: 0 20px !important;
              background: transparent !important;
          }

          div#category-container.error-category-page div.category-navigation a.nav-category-btn {
              padding: 15px 55px !important;
              border: 2px solid {{ current_category.color }} !important;
              border-radius: 8px !important;
              background: white !important;
              color: {{ current_category.color }} !important;
              text-decoration: none !important;
              font-weight: 500 !important;
              transition: all 0.3s ease !important;
              font-size: 11px !important;
              white-space: nowrap !important;
              box-shadow: 0 2px 8px rgba(0,0,0,0.1) !important;
              min-height: 80px !important;
              display: flex !important;
              align-items: center !important;
              justify-content: center !important;
              text-align: center !important;
              line-height: 1.2 !important;
              font-family: inherit !important;
          }

          div#category-container.error-category-page div.category-navigation a.nav-category-btn:hover {
              background: {{ current_category.color }} !important;
              color: white !important;
              text-decoration: none !important;
              transform: translateY(-1px) !important;
          }

          div#category-container.error-category-page div.category-navigation a.nav-category-btn.active {
              background: {{ current_category.color }} !important;
              background-color: {{ current_category.color }} !important;
              color: white !important;
              box-shadow: 0 4px 15px rgba(0,0,0,0.2) !important;
              transform: translateY(-2px) !important;
              border-color: {{ current_category.color_secondary }} !important;
              border: 2px solid {{ current_category.color_secondary }} !important;
              font-weight: 600 !important;
          }
          
          /* Extra specific selector to override any inline styles */
          div#category-container.error-category-page div.category-navigation a.nav-category-btn[class*="active"] {
              background: {{ current_category.color }} !important;
              background-color: {{ current_category.color }} !important;
              color: white !important;
          }

          /* Three Column Layout - Allow columns to grow */
          div#category-container.error-category-page div.three-column-layout {
              display: grid !important;
              grid-template-columns: minmax(300px, 1fr) minmax(280px, auto) minmax(300px, 1fr) !important;
              gap: 30px !important;
              margin-top: 30px !important;
              padding: 0 10px !important;
              width: 100% !important;
              max-width: none !important;
          }

          .error-list-container {
              background: white;
              border-radius: 16px;
              box-shadow: 0 8px 30px rgba(0,0,0,0.12);
              overflow: hidden;
              border: 1px solid rgba(0,0,0,0.05);
          }

          .checkbox-column {
              background: white;
              border-radius: 16px;
              box-shadow: 0 8px 30px rgba(0,0,0,0.12);
              overflow: hidden;
              border: 1px solid rgba(0,0,0,0.05);
          }

          .checkbox-header {
              background: #2c3e50;
              color: white;
              padding: 25px 20px;
              text-align: center;
              position: relative;
          }

          .checkbox-header::before,
          .checkbox-header::after {
              content: '';
              position: absolute;
              left: 50%;
              transform: translateX(-50%);
              width: 80%;
              height: 1px;
              background: rgba(255,255,255,0.2);
          }

          .checkbox-header::before {
              top: 0;
          }

          .checkbox-header::after {
              bottom: 0;
          }

          .checkbox-header h3 {
              margin: 0;
              font-size: 1.2rem;
              padding: 15px 10px;
              line-height: 1.4;
          }

          .checkbox-list {
              padding: 25px;
              max-height: 600px;
              overflow-y: auto;
          }

          .checkbox-item {
              display: flex;
              align-items: center;
              margin-bottom: 15px;
              padding: 12px;
              border-radius: 8px;
              transition: background-color 0.2s;
          }

          .checkbox-item:hover {
              background-color: #f8f9fa;
          }

          .checkbox-item input[type="checkbox"] {
              margin-right: 10px;
              transform: scale(1.2);
          }

          .checkbox-item label {
              cursor: pointer;
              color: #2c3e50;
              font-weight: 500;
              padding: 2px 8px;
              line-height: 1.4;
          }

          .prompt-generation-column {
              background: white;
              border-radius: 16px;
              box-shadow: 0 8px 30px rgba(0,0,0,0.12);
              overflow: hidden;
              border: 1px solid rgba(0,0,0,0.05);
          }

          .prompt-header {
              background: #27ae60;
              color: white;
              padding: 25px 20px;
              text-align: center;
              position: relative;
          }

          .prompt-header::before,
          .prompt-header::after {
              content: '';
              position: absolute;
              left: 50%;
              transform: translateX(-50%);
              width: 80%;
              height: 1px;
              background: rgba(255,255,255,0.2);
          }

          .prompt-header::before {
              top: 0;
          }

          .prompt-header::after {
              bottom: 0;
          }

          .prompt-header h3 {
              margin: 0;
              font-size: 1.2rem;
              padding: 15px 15px;
              line-height: 1.4;
          }

          .prompt-content {
              padding: 35px;
              position: relative;
          }

          .prompt-textarea {
              width: 100%;
              min-height: 400px;
              padding: 25px 50px 25px 25px; /* Top, Right (space for copy icon), Bottom, Left */
              border: 2px solid #bdc3c7;
              border-radius: 10px;
              font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
              font-size: 13px;
              line-height: 1.5;
              resize: vertical;
              background: white;
              color: #2c3e50;
              box-sizing: border-box;
          }

          .prompt-textarea:focus {
              outline: none;
              border-color: #27ae60;
          }

          .copy-icon {
              position: absolute;
              top: 45px;
              right: 45px;
              width: 24px;
              height: 24px;
              background: #3498db;
              color: white;
              border: none;
              border-radius: 6px;
              cursor: pointer;
              display: none;
              align-items: center;
              justify-content: center;
              font-size: 14px;
              transition: all 0.3s ease;
              box-shadow: 0 2px 8px rgba(0,0,0,0.1);
              z-index: 10;
              background-image: url('/assets/img/copy.png');
              background-size: 16px 16px;
              background-repeat: no-repeat;
              background-position: center;
          }
          
          .copy-icon.show {
              display: flex;
          }

          .copy-icon:hover {
              background: #2980b9;
              transform: scale(1.1);
          }

          .copy-icon:disabled {
              background: #bdc3c7;
              cursor: not-allowed;
              transform: none;
          }

          .prompt-actions {
              margin-top: 25px;
              display: flex;
              justify-content: center;
              gap: 15px;
              flex-wrap: wrap;
          }

          .generate-prompt-btn {
              padding: 12px 24px;
              border: none;
              border-radius: 8px;
              font-weight: 500;
              cursor: pointer;
              transition: all 0.3s ease;
              font-size: 14px;
              display: flex;
              align-items: center;
              gap: 10px;
              box-shadow: 0 2px 8px rgba(0,0,0,0.1);
              background: #27ae60;
              color: white;
          }

          .generate-prompt-btn:hover {
              background: #229954;
              transform: translateY(-1px);
          }

          .error-list-header {
              background: #2c3e50;
              color: white;
              padding: 25px 20px;
              text-align: center;
              position: relative;
          }

          .error-list-header::before,
          .error-list-header::after {
              content: '';
              position: absolute;
              left: 50%;
              transform: translateX(-50%);
              width: 80%;
              height: 1px;
              background: rgba(255,255,255,0.2);
          }

          .error-list-header::before {
              top: 0;
          }

          .error-list-header::after {
              bottom: 0;
          }

          .error-list-header h2 {
              margin: 0 0 15px 0;
              font-size: 1.5rem;
              padding: 15px 10px;
              line-height: 1.3;
          }

          .error-count {
              background: rgba(255,255,255,0.2);
              padding: 8px 18px;
              border-radius: 20px;
              font-size: 0.9rem;
              display: inline-block;
              margin-top: 5px;
          }

          .error-list {
              padding: 0;
              margin: 0;
              list-style: none;
          }

          /* Error Items - Isolated styling */
          div#category-container.error-category-page .error-list .error-item {
              padding: 20px 30px !important;
              border-bottom: 2px solid #bdc3c7 !important;
              transition: background-color 0.3s ease !important;
              text-align: center !important;
              background: white !important;
          }

          div#category-container.error-category-page .error-list .error-item:hover {
              background: #f8f9fa !important;
          }

          div#category-container.error-category-page .error-list .error-item:last-child {
              border-bottom: 2px solid #bdc3c7 !important;
          }

          /* Error ID - Isolated styling */
          div#category-container.error-category-page .error-list .error-item .error-id {
              font-weight: 600 !important;
              color: {{ current_category.color }} !important;
              font-size: 1.2rem !important;
              margin: 0 !important;
              text-align: center !important;
              font-family: inherit !important;
          }

          .error-description {
              color: #2c3e50;
              line-height: 1.6;
              margin-bottom: 25px;
              font-size: 16px;
          }

          .code-sections {
              display: grid;
              grid-template-columns: 1fr 1fr;
              gap: 25px;
              margin-bottom: 25px;
          }

          .code-section {
              background: #f8f9fa;
              border-radius: 10px;
              overflow: hidden;
              border: 1px solid #e9ecef;
              box-shadow: 0 2px 8px rgba(0,0,0,0.05);
          }

          .code-section h4 {
              background: #2c3e50;
              color: white;
              padding: 18px 25px;
              margin: 0;
              font-size: 14px;
              font-weight: 600;
              line-height: 1.4;
              letter-spacing: 0.5px;
          }

          .code-content {
              padding: 20px;
              font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
              font-size: 13px;
              line-height: 1.5;
              white-space: pre-wrap;
              word-break: break-word;
              max-height: 300px;
              overflow-y: auto;
              background: white;
          }

          .error-meta {
              display: flex;
              gap: 25px;
              font-size: 0.9rem;
              color: #7f8c8d;
              margin-top: 20px;
              flex-wrap: wrap;
          }

          .error-meta span {
              display: flex;
              align-items: center;
              gap: 5px;
          }

          .no-errors {
              text-align: center;
              padding: 60px 20px;
              color: #7f8c8d;
              font-style: italic;
          }

          .no-errors h3 {
              color: #27ae60;
              margin-bottom: 15px;
              padding: 0 10px;
              line-height: 1.4;
          }

          .no-errors p {
              padding: 0 15px 25px 15px;
              line-height: 1.5;
              margin-bottom: 10px;
          }

          @media (max-width: 1200px) {
              div#category-container.error-category-page div.three-column-layout {
                  grid-template-columns: 1fr !important;
                  gap: 15px !important;
              }
          }

          @media (max-width: 768px) {
              .category-header h1 {
                  font-size: 1.8rem;
              }
              
              .code-sections {
                  grid-template-columns: 1fr;
                  gap: 15px;
              }
              
              .error-meta {
                  flex-direction: column;
                  gap: 8px;
              }
              
              .error-item {
                  padding: 20px;
              }
              
              .category-navigation {
                  gap: 5px;
              }
              
              .nav-category-btn {
                  font-size: 10px;
                  padding: 10px 35px;
                  min-height: 60px;
              }

              .prompt-textarea {
                  min-height: 300px;
              }

              .prompt-actions {
                  flex-direction: column;
                  gap: 8px;
              }

              .generate-prompt-btn, .copy-prompt-btn, .download-prompt-btn {
                  width: 100%;
                  justify-content: center;
              }
          }
          </style>

          <div id="category-container" class="error-category-page">
              <!-- Category Navigation -->
              <div class="category-navigation">
                  {% for category in site.data.error_categories.categories %}
                  <a href="{{ category.permalink }}" 
                     class="nav-category-btn{% if category.slug == category_slug %} active{% endif %}"
                     data-category-color="{{ category.color }}"
                     data-category-secondary="{{ category.color_secondary }}"
                     style="{% if category.slug == category_slug %}background: {{ category.color }} !important; color: white !important; border-color: {{ category.color_secondary }} !important;{% else %}border-color: {{ category.color }}; color: {{ category.color }};{% endif %}">
                      {{ category.name }}
                  </a>
                  {% endfor %}
              </div>

              <div class="category-header">
                  <h1>{{ current_category.name }}</h1>
                  <p>{{ current_category.description }}</p>
                  <div style="margin-top: 25px;">
                      <a href="/code-comprehension/finished-annotating-main/" id="backToAnalysisBtn" class="back-link" 
                         style="background: {{ current_category.color }}; color: white; border: none; cursor: pointer; padding: 12px 24px; border-radius: 8px; font-weight: 500; transition: all 0.3s ease; text-decoration: none; display: inline-block;">
                          ‚Üê Back to Analysis
                      </a>
                  </div>
              </div>

              <div class="three-column-layout">
                  <!-- Left Column: Error List -->
                  <div class="error-list-container">
                      <div class="error-list-header">
                          <div>&nbsp;</div>
                          <h2> Annotated Errors </h2>
                          <div>&nbsp;</div>
                          <div class="error-count" id="errorCount">0 errors found</div>
                      </div>
                      
                      <div id="errorListContent">
                          <!-- Error list will be populated here -->
                      </div>
                  </div>

                  <!-- Middle Column: Error Checkboxes -->
                  <div class="checkbox-column">
                      <div class="checkbox-header">
                          <div>&nbsp;</div>
                          <h3> Select Errors </h3>
                          <div>&nbsp;</div>
                      </div>
                      <div class="checkbox-list" id="errorCheckboxes">
                          <!-- Error checkboxes will be populated here -->
                      </div>
                  </div>

                  <!-- Right Column: Prompt Generation -->
                  <div class="prompt-generation-column">
                      <div class="prompt-header">
                          <div>&nbsp;</div>
                          <h3> Generalizations </h3>
                          <div>&nbsp;</div>
                      </div>
                      <div class="prompt-content">
                          <textarea id="promptTextarea" class="prompt-textarea" placeholder="select errors this generalization applies to"></textarea>
                          <button id="copyPromptBtn" class="copy-icon" disabled title="Copy to clipboard"></button>
                          <div class="prompt-actions">
                              <button id="generatePromptBtn" class="generate-prompt-btn">üöÄ Generate Prompt</button>
                          </div>
                      </div>
                  </div>
              </div>
          </div>

          <script>
          console.log('Error Category {{ current_category.number }} - Script loaded');

          class ErrorCategoryViewer {
              constructor() {
                  this.categoryNumber = {{ current_category.number }};
                  this.categorySlug = '{{ current_category.slug }}';
                  this.categoryName = '{{ current_category.name }}';
                  this.annotations = {};
                  this.csvData = [];
                  this.categoryErrors = [];
                  this.selectedErrors = new Set();
                  this.categoryMapping = null;
                  this.existingPrompt = `You are an assistant specialized in refactoring code using for novices. Your goal is to make code more **readable**, **understandable**, and **maintainable** for novices.

# Refactoring Evaluation
You must first **evaluate whether the code needs refactoring**.
- If the code is **already clean and well-structured**, return it unchanged.
- Apply small improvements (e.g., renaming, adding comments) if they enhance clarity without altering semantics.

# Guide for refactoring
Look for:
- Long or deeply nested functions
- Multiple concerns per method
- Poor or inconsistent naming
- Overuse of control flow or asynchronous patterns

When refactoring:
Do this:
- Break logic into focused, small units
- Preserve clear, sequential flow
- Use self-descriptive names
- Reduce nesting and deep control structures

Don't do this:
If a function is not returning anything, it's not correct refactoring. Do not do it.
Example: 
Wrong Code
What you should do:
Correct Code
-
-


Now for the given code snippet, do Code Refactoring using the above guideline:

Code script:
{code}

Write the refactored code output in the same code language and format.
Note the primary method in the code that a user needs to call.
**Do not write the reasoning and explanation.**

Return in the following JSON format:

{
  "output": {
    "refactored_code": "[refactored code here]",
    "primary_method": "[primary method name here]"
  }
}`;
                  
                  this.initializeAsync();
              }

              async initializeAsync() {
                  await this.loadData();
              }
              
              async loadData() {
                  try {
                      // Load category mapping from localStorage first (generated during CSV upload)
                      this.loadCategoryMappingFromStorage();
                      
                      // Prioritize localStorage data (actual user annotations)
                      const storedAnnotations = localStorage.getItem('errorAnnotations');
                      const storedCsvData = localStorage.getItem('csvData');
                      
                      if (storedAnnotations) {
                          this.annotations = JSON.parse(storedAnnotations);
                          console.log('Loaded user annotations from localStorage:', Object.keys(this.annotations).length, 'entries');
                      }
                      
                      if (storedCsvData) {
                          this.csvData = JSON.parse(storedCsvData);
                          console.log('Loaded user CSV data from localStorage:', this.csvData.length, 'entries');
                      }
                      
                      // Only use the sample JSON file if no user data exists (for demo purposes)
                      if (Object.keys(this.annotations).length === 0) {
                          console.log('No user annotations found, checking for sample data...');
                          await this.loadFromJsonFile();
                      }
                      
                      this.displayErrors();
                  } catch (error) {
                      console.error('Error loading category data:', error);
                      this.showNoData();
                  }
              }

              async loadFromJsonFile() {
                  try {
                      // Try to load from annotated-code.json file first (fallback for demo purposes)
                      const response = await fetch('/annotated-code.json');
                      if (response.ok) {
                          const jsonData = await response.json();
                          console.log('Loaded annotated-code.json:', jsonData);
                          
                          // Extract annotations and CSV data from the JSON structure
                          if (jsonData.annotations) {
                              this.annotations = jsonData.annotations;
                          }
                          
                          if (jsonData.csvData) {
                              this.csvData = jsonData.csvData;
                          }
                          
                          // Also check for entry_tags format (alternative structure)
                          if (jsonData.entry_tags) {
                              this.annotations = jsonData.entry_tags;
                          }
                          
                          console.log('Processed annotations:', Object.keys(this.annotations).length, 'entries');
                          console.log('Processed CSV data:', this.csvData.length, 'entries');
                      } else {
                          console.log('annotated-code.json not found, falling back to localStorage');
                      }
                  } catch (error) {
                      console.log('Could not load annotated-code.json:', error.message);
                  }
              }

              /**
               * Load category mapping from localStorage (generated during CSV upload)
               */
              loadCategoryMappingFromStorage() {
                  try {
                      const storedMapping = localStorage.getItem('errorCategoryMapping');
                      if (storedMapping) {
                          this.categoryMapping = JSON.parse(storedMapping);
                          console.log('Loaded error category mapping from localStorage:', this.categoryMapping);
                          console.log('CSV data mapping entries:', Object.keys(this.categoryMapping.csv_data_mapping || {}).length);
                      } else {
                          console.log('No error category mapping found in localStorage');
                          // Create a basic fallback mapping
                          this.createFallbackMapping();
                      }
                  } catch (error) {
                      console.error('Error loading category mapping from localStorage:', error);
                      this.createFallbackMapping();
                  }
              }

              /**
               * Create a fallback mapping if none exists
               */
              createFallbackMapping() {
                  this.categoryMapping = {
                      error_categories: {
                          "1": "Incorrect Argument Count",
                          "2": "Argument Unpacking Error", 
                          "3": "Incorrect Formula Application",
                          "4": "Off By One Error",
                          "5": "Incorrect Output Format",
                          "6": "Edge Case Handling Failure",
                          "7": "Syntax Error"
                      },
                      category_details: {
                          "Incorrect Argument Count": { "number": 1, "color": "#e74c3c" },
                          "Argument Unpacking Error": { "number": 2, "color": "#3498db" },
                          "Incorrect Formula Application": { "number": 3, "color": "#2ecc71" },
                          "Off By One Error": { "number": 4, "color": "#f39c12" },
                          "Incorrect Output Format": { "number": 5, "color": "#9b59b6" },
                          "Edge Case Handling Failure": { "number": 6, "color": "#1abc9c" },
                          "Syntax Error": { "number": 7, "color": "#34495e" }
                      },
                      csv_data_mapping: {},
                      metadata: { "description": "Fallback mapping" }
                  };
                  console.log('Created fallback error category mapping');
              }
              
              displayErrors() {
                  console.log('Displaying errors for category:', this.categoryName);
                  console.log('Available annotations:', Object.keys(this.annotations).length);
                  console.log('Available CSV data:', this.csvData.length);
                  console.log('Category mapping available:', !!this.categoryMapping);
                  
                  // Find all errors in this category
                  this.categoryErrors = [];
                  
                  // Get current category info from mapping
                  const currentCategoryInfo = this.getCategoryInfo(this.categoryName);
                  console.log('Current category info from mapping:', currentCategoryInfo);
                  
                  Object.entries(this.annotations).forEach(([entryId, tags]) => {
                      // Handle both array and string tag formats
                      const tagArray = Array.isArray(tags) ? tags : [tags];
                      
                      // Check if any tag matches the current category name
                      let matchesCategory = tagArray.includes(this.categoryName);
                      
                      if (!matchesCategory && currentCategoryInfo) {
                          // Also try matching by category number
                          matchesCategory = tagArray.includes(currentCategoryInfo.number.toString()) ||
                                          tagArray.includes(`Category ${currentCategoryInfo.number}`) ||
                                          tagArray.includes(`Error ${currentCategoryInfo.number}`);
                      }
                      
                      if (matchesCategory) {
                          console.log('Found matching entry:', entryId, 'with tags:', tagArray);
                          
                          // Get the CSV error number from mapping if available
                          let csvErrorNumber = null;
                          let csvEntry = null;
                          
                          if (this.categoryMapping?.csv_data_mapping?.[entryId]) {
                              csvErrorNumber = this.categoryMapping.csv_data_mapping[entryId].error_number;
                              // Use the CSV data from the mapping for consistency
                              const mappingEntry = this.categoryMapping.csv_data_mapping[entryId];
                              csvEntry = {
                                  task_id: mappingEntry.task_id,
                                  text: mappingEntry.description,
                                  'original code': mappingEntry.original_code,
                                  refactored_code: mappingEntry.refactored_code,
                                  original_test_result: mappingEntry.test_result
                              };
                          } else {
                              // Fallback to finding in CSV data
                              csvEntry = this.csvData.find(entry => 
                                  (entry.task_id && entry.task_id === entryId) || 
                                  entryId.includes(entry.task_id) ||
                                  (entry.id && entry.id === entryId)
                              );
                              
                              if (csvEntry) {
                                  // Find the index in CSV data to get error number
                                  csvErrorNumber = this.csvData.findIndex(entry => 
                                      (entry.task_id && entry.task_id === entryId) || 
                                      entryId.includes(entry.task_id) ||
                                      (entry.id && entry.id === entryId)
                                  ) + 1;
                              }
                          }
                          
                          if (csvEntry) {
                              this.categoryErrors.push({
                                  id: entryId,
                                  entry: csvEntry,
                                  tags: tagArray,
                                  csvErrorNumber: csvErrorNumber || 'Unknown'
                              });
                          } else {
                              console.log('No CSV entry found for:', entryId);
                          }
                      }
                  });
                  
                  console.log('Category errors found:', this.categoryErrors.length);
                  
                  // Update error count with category number and CSV info
                  const countText = currentCategoryInfo ? 
                      `${this.categoryErrors.length} errors found (Category ${currentCategoryInfo.number})` :
                      `${this.categoryErrors.length} errors found`;
                  document.getElementById('errorCount').textContent = countText;
                  
                  // Display errors and checkboxes
                  if (this.categoryErrors.length === 0) {
                      // Check if we have any annotations at all
                      if (Object.keys(this.annotations).length === 0) {
                          this.showNoAnnotations();
                      } else {
                          this.showNoErrors();
                      }
                      this.showNoCheckboxes();
                  } else {
                      this.showErrorList(this.categoryErrors);
                      this.showErrorCheckboxes(this.categoryErrors);
                  }
              }
              
              showErrorList(errors) {
                  const container = document.getElementById('errorListContent');
                  
                  if (errors.length === 0) {
                      this.showNoErrors();
                      return;
                  }
                  
                  let html = '<ul class="error-list">';
                  
                  errors.forEach((error, index) => {
                      const description = error.entry.text || error.entry.task_description || error.entry.description || 'No description available';
                      const originalCode = error.entry['original code'] || error.entry.original_code || error.entry.code || 'No original code available';
                      const refactoredCode = this.extractRefactoredCode(error.entry.refactored_code) || 'No refactored code available';
                      const originalResult = error.entry.original_test_result || error.entry.original_result || 'No result';
                      const refactoredResult = error.entry.refactored_test_result || error.entry.refactored_result || 'No result';
                      
                      html += `
                          <li class="error-item">
                              <div class="error-id">CSV Error #${error.csvErrorNumber || (index + 1)}: ${error.entry.task_id || 'Unknown ID'}</div>
                              <div class="error-description">${description}</div>
                              
                              <div class="code-sections">
                                  <div class="code-section">
                                      <h4>Original Code (Contains Error)</h4>
                                      <div class="code-content">${originalCode}</div>
                                  </div>
                                  <div class="code-section">
                                      <h4>Refactored Code (Fixed)</h4>
                                      <div class="code-content">${refactoredCode}</div>
                                  </div>
                              </div>
                              
                              <div class="error-meta">
                                  <span>üìù Task: ${error.entry.task_id || 'Unknown'}</span>
                                  <span>üî¢ CSV Position: ${error.csvErrorNumber || 'Unknown'}</span>
                                  <span>üêõ Error Type: ${this.categoryName}</span>
                                  <span>‚úÖ Test Result: ${originalResult === 'TRUE' ? 'Pass' : 'Fail'}</span>
                              </div>
                          </li>
                      `;
                  });
                  
                  html += '</ul>';
                  container.innerHTML = html;
              }
              
              extractRefactoredCode(refactoredCodeField) {
                  if (!refactoredCodeField) return 'No refactored code available';
                  
                  // Check if it starts with ```json (from the CSV)
                  if (refactoredCodeField.trim().startsWith('```json')) {
                      try {
                          // Extract JSON content between ```json and ```
                          const jsonMatch = refactoredCodeField.match(/```json\s*\n([\s\S]*?)\n```/);
                          if (jsonMatch) {
                              const jsonStr = jsonMatch[1];
                              // Parse the JSON and extract the refactored_code
                              const parsed = JSON.parse(jsonStr);
                              if (parsed.output && parsed.output.refactored_code) {
                                  // Unescape the code
                                  return parsed.output.refactored_code.replace(/\\n/g, '\n').replace(/\\"/g, '"');
                              }
                          }
                      } catch (e) {
                          console.warn('Failed to parse JSON-wrapped refactored code:', e);
                      }
                  }
                  
                  // Return as-is if not JSON-wrapped
                  return refactoredCodeField;
              }
              
              showErrorCheckboxes(errors) {
                  const container = document.getElementById('errorCheckboxes');
                  
                  if (errors.length === 0) {
                      container.innerHTML = `
                          <div style="text-align: center; color: #7f8c8d; font-style: italic; padding: 20px;">
                              No errors found in this category
                          </div>
                      `;
                      return;
                  }
                  
                  let html = '';
                  errors.forEach((error, index) => {
                      const displayNumber = index + 1; // For checkbox identification
                      const csvErrorNumber = error.csvErrorNumber || displayNumber;
                      const description = error.entry.text || error.entry.task_description || error.entry.description || 'No description available';
                      // Truncate description for display
                      const shortDescription = description.length > 35 ? description.substring(0, 35) + '...' : description;
                      
                      html += `
                          <div class="checkbox-item">
                              <input type="checkbox" id="error_${displayNumber}" value="${displayNumber}" 
                                     onchange="errorCategoryViewer.onCheckboxChange(${displayNumber})">
                              <label for="error_${displayNumber}" title="${description}">
                                  CSV #${csvErrorNumber}: ${shortDescription}
                              </label>
                          </div>
                      `;
                  });
                  
                  container.innerHTML = html;
              }

              showNoCheckboxes() {
                  const container = document.getElementById('errorCheckboxes');
                  container.innerHTML = `
                      <div style="text-align: center; color: #7f8c8d; font-style: italic; padding: 20px;">
                          No errors found in this category
                      </div>
                  `;
              }

              onCheckboxChange(errorNumber) {
                  if (document.getElementById(`error_${errorNumber}`).checked) {
                      this.selectedErrors.add(errorNumber);
                  } else {
                      this.selectedErrors.delete(errorNumber);
                  }
                  this.updateGeneralization();
              }

              updateGeneralization() {
                  const textarea = document.getElementById('promptTextarea');
                  const copyBtn = document.getElementById('copyPromptBtn');
                  
                  if (this.selectedErrors.size === 0) {
                      textarea.value = `select errors this generalization applies to`;
                      // Hide copy button when no errors selected
                      copyBtn.disabled = true;
                      copyBtn.classList.remove('show');
                      return;
                  }

                  // Get selected error data
                  const selectedErrorData = Array.from(this.selectedErrors).map(errorNum => {
                      const errorIndex = errorNum - 1;
                      return this.categoryErrors[errorIndex];
                  });

                  // Generate generalization
                  const generalization = this.generateGeneralization(selectedErrorData);
                  textarea.value = generalization;
                  
                  // Enable and show copy button since we have content
                  copyBtn.disabled = false;
                  copyBtn.classList.add('show');
              }

              generateGeneralization(selectedErrors) {
                  // Create the new generalization section
                  let generalizationSection = '\ngeneralization ```\n';
                  
                  selectedErrors.forEach(error => {
                      const originalCode = error.entry['original code'] || 'No original code available';
                      const refactoredCode = this.extractRefactoredCode(error.entry.refactored_code) || 'No refactored code available';
                      
                      generalizationSection += `<original code>\n${originalCode}\n\n<refactored code>\n${refactoredCode}\n\n`;
                  });

                  // Add common patterns analysis
                  const commonPatterns = this.analyzeCommonPatterns(selectedErrors);
                  generalizationSection += `<what these have in common>\n${commonPatterns}\n```\n\n`;

                  // Get all annotation data for the existing analysis section
                  const totalAnnotated = Object.keys(this.annotations).length;
                  const analysis = this.analyzeAnnotationPatterns();

                  // Create the full prompt with existing structure
                  return `${this.existingPrompt}

${generalizationSection}## CRITICAL ERROR PREVENTION ANALYSIS

Based on analysis of ${totalAnnotated} annotated error cases, the following patterns have been identified to help prevent common LLM mistakes:

### Error Patterns Identified from Annotations:

${this.generateErrorPatternSections(analysis)}

### MANDATORY REQUIREMENTS:
1. **Function Signatures**: Always verify the exact number and names of parameters required
2. **Variable Names**: Ensure all variables are properly defined before use  
3. **Return Types**: Match expected return formats exactly
4. **Test Compatibility**: Code must pass the provided test cases without modification
5. **Syntax Validation**: Check for proper Python syntax, indentation, and brackets

### QUALITY CHECKLIST:
- [ ] Function signature matches test calls exactly
- [ ] All variables are defined before use
- [ ] Return format matches expected output
- [ ] No syntax errors or typos
- [ ] Logic handles edge cases properly

Remember: These ${totalAnnotated} errors were identified through careful analysis. Focus on correctness over complexity.`;
              }

              analyzeCommonPatterns(selectedErrors) {
                  const patterns = [];
                  
                  // Analyze common issues
                  const tags = selectedErrors.flatMap(error => error.tags);
                  const tagCounts = {};
                  tags.forEach(tag => {
                      tagCounts[tag] = (tagCounts[tag] || 0) + 1;
                  });

                  const commonTags = Object.entries(tagCounts)
                      .filter(([tag, count]) => count > 1)
                      .map(([tag, count]) => `${tag} (${count} occurrences)`);

                  if (commonTags.length > 0) {
                      patterns.push(`Common error types: ${commonTags.join(', ')}`);
                  }

                  // Add category-specific analysis
                  patterns.push(`All errors belong to the "${this.categoryName}" category`);
                  patterns.push(`Selected ${selectedErrors.length} errors for analysis`);

                  return patterns.join('\n');
              }

              analyzeAnnotationPatterns() {
                  const tagCounts = {};
                  Object.values(this.annotations).forEach(tags => {
                      tags.forEach(tag => {
                          tagCounts[tag] = (tagCounts[tag] || 0) + 1;
                      });
                  });
                  
                  const errorTypes = {};
                  Object.values(this.annotations).forEach(tags => {
                      tags.forEach(tag => {
                          if (tag.toLowerCase().includes('signature') || tag.toLowerCase().includes('argument')) {
                              errorTypes['Function Signature Issues'] = (errorTypes['Function Signature Issues'] || 0) + 1;
                          } else if (tag.toLowerCase().includes('logical') || tag.toLowerCase().includes('algorithm')) {
                              errorTypes['Logic/Algorithm Errors'] = (errorTypes['Logic/Algorithm Errors'] || 0) + 1;
                          } else if (tag.toLowerCase().includes('syntax') || tag.toLowerCase().includes('environment')) {
                              errorTypes['Syntax/Environment Issues'] = (errorTypes['Syntax/Environment Issues'] || 0) + 1;
                          } else {
                              errorTypes['Other Issues'] = (errorTypes['Other Issues'] || 0) + 1;
                          }
                      });
                  });
                  
                  return { tagCounts, errorTypes };
              }

              generateErrorPatternSections(analysis) {
                  let sections = '';
                  let count = 1;
                  
                  Object.entries(analysis.errorTypes).forEach(([category, occurrences]) => {
                      sections += `\n${count}. **${category}** - ${this.getCategoryDescription(category)}
   Frequency: ${occurrences} instances identified
   Focus Area: ${this.getCategoryFocusArea(category)}\n`;
                      count++;
                  });
                  
                  const topTags = Object.entries(analysis.tagCounts)
                      .sort(([,a], [,b]) => b - a)
                      .slice(0, 5);
                      
                  if (topTags.length > 0) {
                      sections += `\n### Most Common Annotation Tags:`;
                      topTags.forEach(([tag, count]) => {
                          sections += `\n‚Ä¢ ${tag}: ${count} occurrences`;
                      });
                  }
                  
                  return sections;
              }

              getCategoryDescription(category) {
                  const descriptions = {
                      'Function Signature Issues': 'Wrong number/type of function parameters',
                      'Logic/Algorithm Errors': 'Incorrect implementation of algorithm logic',
                      'Syntax/Environment Issues': 'Code syntax and environment setup problems',
                      'Other Issues': 'Various other coding problems identified'
                  };
                  return descriptions[category] || 'Code execution issues';
              }

              getCategoryFocusArea(category) {
                  const focusAreas = {
                      'Function Signature Issues': 'Parameter validation and function call matching',
                      'Logic/Algorithm Errors': 'Algorithm correctness and edge case handling',
                      'Syntax/Environment Issues': 'Python syntax rules and environment setup',
                      'Other Issues': 'General code quality and best practices'
                  };
                  return focusAreas[category] || 'Code quality improvement';
              }

              generateEnhancedPrompt() {
                  // Always generate the prompt, no matter what
                  const textarea = document.getElementById('promptTextarea');
                  const copyBtn = document.getElementById('copyPromptBtn');
                  
                  if (this.selectedErrors.size === 0) {
                      // Generate a basic prompt even without selected errors
                      const basicPrompt = this.generateBasicPrompt();
                      textarea.value = basicPrompt;
                  } else {
                      // The prompt is already generated in the textarea via updateGeneralization
                      // Just update the button state
                      copyBtn.disabled = false;
                      copyBtn.classList.add('show');
                  }
                  
                  // Show success message
                  const button = document.getElementById('generatePromptBtn');
                  const originalText = button.innerHTML;
                  button.innerHTML = '‚úÖ Prompt Generated!';
                  button.style.background = '#27ae60';
                  
                  setTimeout(() => {
                      button.innerHTML = originalText;
                      button.style.background = '#27ae60';
                  }, 2000);
              }
              
              generateBasicPrompt() {
                  const totalAnnotated = Object.keys(this.annotations).length;
                  const analysis = this.analyzeAnnotationPatterns();
                  
                  return `${this.existingPrompt}

## CRITICAL ERROR PREVENTION ANALYSIS

Based on analysis of ${totalAnnotated} annotated error cases, the following patterns have been identified to help prevent common LLM mistakes:

### Error Patterns Identified from Annotations:

${this.generateErrorPatternSections(analysis)}

### MANDATORY REQUIREMENTS:
1. **Function Signatures**: Always verify the exact number and names of parameters required
2. **Variable Names**: Ensure all variables are properly defined before use  
3. **Return Types**: Match expected return formats exactly
4. **Test Compatibility**: Code must pass the provided test cases without modification
5. **Syntax Validation**: Check for proper Python syntax, indentation, and brackets

### QUALITY CHECKLIST:
- [ ] Function signature matches test calls exactly
- [ ] All variables are defined before use
- [ ] Return format matches expected output
- [ ] No syntax errors or typos
- [ ] Logic handles edge cases properly

Remember: These ${totalAnnotated} errors were identified through careful analysis. Focus on correctness over complexity.`;
              }

              copyPromptToClipboard() {
                  const textarea = document.getElementById('promptTextarea');
                  const promptText = textarea.value;
                  
                  if (!promptText || promptText.includes('select errors this generalization applies to')) {
                      alert('Please generate a prompt first by clicking "Generate Prompt".');
                      return;
                  }

                  navigator.clipboard.writeText(promptText).then(() => {
                      const button = document.getElementById('copyPromptBtn');
                      const originalText = button.innerHTML;
                      button.innerHTML = '‚úÖ Copied!';
                      
                      setTimeout(() => {
                          button.innerHTML = originalText;
                      }, 2000);
                  }).catch(err => {
                      console.error('Failed to copy prompt: ', err);
                      alert('Failed to copy prompt to clipboard. Please try selecting and copying manually.');
                  });
              }


              showNoErrors() {
                  const container = document.getElementById('errorListContent');
                  container.innerHTML = `
                      <div class="no-errors">
                          <h3>üéØ No "${this.categoryName}" Errors</h3>
                          <p>There are no errors annotated with the "${this.categoryName}" category.</p>
                          <p>This could mean:</p>
                          <ul style="text-align: left; margin: 10px 0; padding-left: 20px;">
                              <li>No errors of this type occurred in your CSV data</li>
                              <li>Errors of this type haven't been annotated yet</li>
                              <li>Errors were annotated with different category names</li>
                          </ul>
                          <div style="margin-top: 15px;">
                              <a href="/error-annotator/" style="color: {{ current_category.color }}; text-decoration: none; font-weight: 500;">‚Üê Continue Annotating</a>
                          </div>
                      </div>
                  `;
              }
              
              showNoAnnotations() {
                  const container = document.getElementById('errorListContent');
                  container.innerHTML = `
                      <div class="no-errors">
                          <h3>üìù No Annotations Yet</h3>
                          <p>You haven't annotated any errors yet. Error category pages show only errors that have been categorized during the annotation process.</p>
                          <p><strong>To get started:</strong></p>
                          <ol style="text-align: left; margin: 15px 0; padding-left: 20px;">
                              <li>Load a CSV file in the Error Annotator</li>
                              <li>Annotate errors by assigning them to categories</li>
                              <li>Return here to see categorized errors</li>
                          </ol>
                          <div style="margin-top: 20px;">
                              <a href="/error-annotator/" style="color: {{ current_category.color }}; text-decoration: none; font-weight: 500; background: {{ current_category.color }}; color: white; padding: 10px 20px; border-radius: 6px;">‚Üê Start Annotating Errors</a>
                          </div>
                      </div>
                  `;
              }

              showNoData() {
                  const container = document.getElementById('errorListContent');
                  container.innerHTML = `
                      <div class="no-errors">
                          <h3>‚ùå No CSV Data Available</h3>
                          <p>No CSV data found. Please return to the Error Annotator and load a CSV file first.</p>
                          <div style="margin-top: 15px;">
                              <a href="/error-annotator/" style="color: {{ current_category.color }}; text-decoration: none; font-weight: 500;">‚Üê Load CSV File</a>
                          </div>
                      </div>
                  `;
              }

              /**
               * Get category information using the mapping JSON
               */
              getCategoryInfo(categoryNameOrNumber) {
                  if (!this.categoryMapping) {
                      return null;
                  }
                  
                  // If it's a number, convert to category name first
                  let categoryName = categoryNameOrNumber;
                  if (typeof categoryNameOrNumber === 'number') {
                      categoryName = this.categoryMapping.error_categories[categoryNameOrNumber.toString()];
                  }
                  
                  // Return the category details
                  return this.categoryMapping.category_details[categoryName] || null;
              }

              /**
               * Get all categories from mapping
               */
              getAllCategories() {
                  if (!this.categoryMapping) {
                      return [];
                  }
                  
                  return Object.entries(this.categoryMapping.error_categories).map(([number, name]) => ({
                      number: parseInt(number),
                      name: name,
                      ...this.categoryMapping.category_details[name]
                  }));
              }

              /**
               * Navigate back to analysis page with current data preserved
               */
              backToAnalysis() {
                  console.log('üîÑ backToAnalysis() method called - attempting navigation');
                  
                  try {
                      // Store current data if available
                      if (this.csvData && this.csvData.length > 0) {
                          localStorage.setItem('csvData', JSON.stringify(this.csvData));
                          console.log('‚úÖ Stored CSV data');
                      }
                      
                      if (this.annotations && Object.keys(this.annotations).length > 0) {
                          localStorage.setItem('errorAnnotations', JSON.stringify(this.annotations));
                          console.log('‚úÖ Stored annotations');
                      }
                      
                      // Simple direct navigation
                      console.log('üöÄ Navigating to /code-comprehension/finished-annotating-main/');
                      window.location.href = '/code-comprehension/finished-annotating-main/';
                      
                  } catch (error) {
                      console.error('‚ùå Error in backToAnalysis:', error);
                      // Force navigation even if storage fails
                      window.location.href = '/code-comprehension/finished-annotating-main/';
                  }
              }

          }

          // Global variable for error category viewer
          let errorCategoryViewer;

          // Initialize when page loads
          document.addEventListener('DOMContentLoaded', () => {
              errorCategoryViewer = new ErrorCategoryViewer();
              
              // Add event listeners for prompt buttons
              document.getElementById('generatePromptBtn').addEventListener('click', () => {
                  errorCategoryViewer.generateEnhancedPrompt();
              });
              
              document.getElementById('copyPromptBtn').addEventListener('click', () => {
                  errorCategoryViewer.copyPromptToClipboard();
              });
              
              // Back to analysis - intercept link click to store data
              setTimeout(() => {
                  const backToAnalysisLink = document.getElementById('backToAnalysisBtn');
                  if (backToAnalysisLink) {
                      backToAnalysisLink.addEventListener('click', (e) => {
                          console.log('üñ±Ô∏è Back to Analysis link clicked - storing data before navigation');
                          
                          try {
                              // Store current data before navigation
                              if (errorCategoryViewer) {
                                  if (errorCategoryViewer.csvData && errorCategoryViewer.csvData.length > 0) {
                                      localStorage.setItem('csvData', JSON.stringify(errorCategoryViewer.csvData));
                                      console.log('‚úÖ Stored CSV data before navigation');
                                  }
                                  
                                  if (errorCategoryViewer.annotations && Object.keys(errorCategoryViewer.annotations).length > 0) {
                                      localStorage.setItem('errorAnnotations', JSON.stringify(errorCategoryViewer.annotations));
                                      console.log('‚úÖ Stored annotations before navigation');
                                  }
                              }
                              
                              // Allow the normal link navigation to proceed
                              console.log('üöÄ Allowing navigation to /finished-annotating/');
                          } catch (error) {
                              console.error('‚ùå Error storing data, but continuing navigation:', error);
                              // Don't prevent navigation even if storage fails
                          }
                      });
                      
                      console.log('‚úÖ Back to Analysis link event listener added successfully');
                  } else {
                      console.error('‚ùå Back to Analysis link not found');
                  }
              }, 500);
          });
          </script>

        </div>

        <!-- Authentication script -->
        <script>
        console.log('Error Category {{ current_category.number }} - Auth script loaded');

        document.addEventListener('authReady', () => {
            console.log('Error Category {{ current_category.number }} - authReady event fired');
            if (window.authService.isAuthenticated) {
                const user = window.authService.user;
                
                // Check user roles in multiple possible locations
                const customRoles = user['https://carsontkempf.github.io/roles'] || [];
                const auth0Roles = user['https://auth0.com/roles'] || [];
                const appMetadataRoles = user.app_metadata?.roles || [];
                const userMetadataRoles = user.user_metadata?.roles || [];
                
                // Check additional possible role locations
                const rolesArray = user.roles || [];
                const authorizationRoles = user.authorization?.roles || [];
                const orgRoles = user['org_roles'] || [];
                const realmRoles = user['realm_roles'] || [];
                
                // Combine all possible role sources
                const allRoles = [...customRoles, ...auth0Roles, ...appMetadataRoles, ...userMetadataRoles, ...rolesArray, ...authorizationRoles, ...orgRoles, ...realmRoles];
                
                const hasAdminRole = allRoles.includes('admin');
                const hasCodeComprehensionRole = allRoles.includes('code-comprehension') || 
                                                allRoles.includes('Code-Comprehension-Project') || 
                                                allRoles.includes('rol_XUUh9ZOhirY2yCQQ');
                const isSiteOwner = user.email === 'ctkfdp@umsystem.edu';
                
                // Check if user has any of the required permissions
                if (hasAdminRole || hasCodeComprehensionRole || isSiteOwner) {
                    document.getElementById('project-content-wrapper').style.display = 'block';
                } else {
                    document.getElementById('auth-check-wrapper').style.display = 'block';
                }
            } else {
                console.log('Error Category {{ current_category.number }} - User not authenticated');
                document.getElementById('auth-check-wrapper').style.display = 'block';
            }
        });

        // If auth service isn't ready after 5 seconds, show access denied
        setTimeout(() => {
            if (!window.authService || !window.authService.isAuthenticated) {
                document.getElementById('auth-check-wrapper').style.display = 'block';
            }
        }, 5000);
        </script>