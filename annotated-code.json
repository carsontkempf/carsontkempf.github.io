{
  "metadata": {
    "total_entries": 50,
    "tagged_entries": 35,
    "export_date": "2024-10-02T10:00:00Z",
    "tool": "Error Annotator Web",
    "description": "Annotated error data for Code Comprehension Project"
  },
  "annotations": {
    "task_001": ["Incorrect Argument Count"],
    "task_002": ["Argument Unpacking Error"],
    "task_003": ["Incorrect Formula Application"],
    "task_004": ["Off By One Error"],
    "task_005": ["Incorrect Output Format"],
    "task_006": ["Edge Case Handling Failure"],
    "task_007": ["Syntax Error"],
    "task_008": ["Incorrect Argument Count"],
    "task_009": ["Argument Unpacking Error"],
    "task_010": ["Incorrect Formula Application"],
    "task_011": ["Off By One Error"],
    "task_012": ["Incorrect Output Format"],
    "task_013": ["Edge Case Handling Failure"],
    "task_014": ["Syntax Error"],
    "task_015": ["Incorrect Argument Count"],
    "task_016": ["Argument Unpacking Error"],
    "task_017": ["Incorrect Formula Application"],
    "task_018": ["Off By One Error"],
    "task_019": ["Incorrect Output Format"],
    "task_020": ["Edge Case Handling Failure"],
    "task_021": ["Syntax Error"],
    "task_022": ["Incorrect Argument Count"],
    "task_023": ["Argument Unpacking Error"],
    "task_024": ["Incorrect Formula Application"],
    "task_025": ["Off By One Error"],
    "task_026": ["Incorrect Output Format"],
    "task_027": ["Edge Case Handling Failure"],
    "task_028": ["Syntax Error"],
    "task_029": ["Incorrect Argument Count"],
    "task_030": ["Argument Unpacking Error"],
    "task_031": ["Incorrect Formula Application"],
    "task_032": ["Off By One Error"],
    "task_033": ["Incorrect Output Format"],
    "task_034": ["Edge Case Handling Failure"],
    "task_035": ["Syntax Error"]
  },
  "csvData": [
    {
      "task_id": "task_001",
      "text": "Write a function that calculates the sum of two numbers",
      "original code": "def add_numbers(a):\n    return a + b",
      "refactored_code": "def add_numbers(a, b):\n    return a + b",
      "original_test_result": "FAIL: NameError: name 'b' is not defined",
      "refactored_test_result": "TRUE",
      "comparison": "DIFFERENT",
      "primary_method": "add_numbers"
    },
    {
      "task_id": "task_002",
      "text": "Create a function that unpacks a tuple and returns the sum",
      "original code": "def sum_tuple(numbers):\n    a, b = numbers\n    return a + b + c",
      "refactored_code": "def sum_tuple(numbers):\n    a, b = numbers\n    return a + b",
      "original_test_result": "FAIL: NameError: name 'c' is not defined",
      "refactored_test_result": "TRUE",
      "comparison": "DIFFERENT",
      "primary_method": "sum_tuple"
    },
    {
      "task_id": "task_003",
      "text": "Calculate the area of a circle given the radius",
      "original code": "def circle_area(radius):\n    return radius * radius",
      "refactored_code": "import math\n\ndef circle_area(radius):\n    return math.pi * radius * radius",
      "original_test_result": "FAIL: Incorrect formula",
      "refactored_test_result": "TRUE",
      "comparison": "DIFFERENT",
      "primary_method": "circle_area"
    },
    {
      "task_id": "task_004",
      "text": "Get the last element of a list",
      "original code": "def get_last(lst):\n    return lst[len(lst)]",
      "refactored_code": "def get_last(lst):\n    return lst[len(lst) - 1]",
      "original_test_result": "FAIL: IndexError: list index out of range",
      "refactored_test_result": "TRUE",
      "comparison": "DIFFERENT",
      "primary_method": "get_last"
    },
    {
      "task_id": "task_005",
      "text": "Return a list of even numbers from 0 to n",
      "original code": "def even_numbers(n):\n    result = []\n    for i in range(n):\n        if i % 2 == 0:\n            result.append(i)\n    return result[0]",
      "refactored_code": "def even_numbers(n):\n    result = []\n    for i in range(n):\n        if i % 2 == 0:\n            result.append(i)\n    return result",
      "original_test_result": "FAIL: Expected list, got int",
      "refactored_test_result": "TRUE",
      "comparison": "DIFFERENT",
      "primary_method": "even_numbers"
    },
    {
      "task_id": "task_006",
      "text": "Divide two numbers safely",
      "original code": "def safe_divide(a, b):\n    return a / b",
      "refactored_code": "def safe_divide(a, b):\n    if b == 0:\n        return 0\n    return a / b",
      "original_test_result": "FAIL: ZeroDivisionError: division by zero",
      "refactored_test_result": "TRUE",
      "comparison": "DIFFERENT",
      "primary_method": "safe_divide"
    },
    {
      "task_id": "task_007",
      "text": "Create a simple greeting function",
      "original code": "def greet(name):\n    return f'Hello {name'",
      "refactored_code": "def greet(name):\n    return f'Hello {name}'",
      "original_test_result": "FAIL: SyntaxError: EOL while scanning string literal",
      "refactored_test_result": "TRUE",
      "comparison": "DIFFERENT",
      "primary_method": "greet"
    },
    {
      "task_id": "task_008",
      "text": "Multiply three numbers together",
      "original code": "def multiply_three(a, b):\n    return a * b * c",
      "refactored_code": "def multiply_three(a, b, c):\n    return a * b * c",
      "original_test_result": "FAIL: NameError: name 'c' is not defined",
      "refactored_test_result": "TRUE",
      "comparison": "DIFFERENT",
      "primary_method": "multiply_three"
    },
    {
      "task_id": "task_009",
      "text": "Extract first and last elements from a list",
      "original code": "def first_last(lst):\n    first, last = lst\n    return (first, last)",
      "refactored_code": "def first_last(lst):\n    first, last = lst[0], lst[-1]\n    return (first, last)",
      "original_test_result": "FAIL: ValueError: too many values to unpack",
      "refactored_test_result": "TRUE",
      "comparison": "DIFFERENT",
      "primary_method": "first_last"
    },
    {
      "task_id": "task_010",
      "text": "Calculate the perimeter of a rectangle",
      "original code": "def rectangle_perimeter(length, width):\n    return length + width",
      "refactored_code": "def rectangle_perimeter(length, width):\n    return 2 * (length + width)",
      "original_test_result": "FAIL: Incorrect formula",
      "refactored_test_result": "TRUE",
      "comparison": "DIFFERENT",
      "primary_method": "rectangle_perimeter"
    },
    {
      "task_id": "task_011",
      "text": "Find the index of the maximum element in a list",
      "original code": "def max_index(lst):\n    max_val = max(lst)\n    return lst.index(max_val) + 1",
      "refactored_code": "def max_index(lst):\n    max_val = max(lst)\n    return lst.index(max_val)",
      "original_test_result": "FAIL: Index off by one",
      "refactored_test_result": "TRUE",
      "comparison": "DIFFERENT",
      "primary_method": "max_index"
    },
    {
      "task_id": "task_012",
      "text": "Return the count of vowels in a string",
      "original code": "def count_vowels(text):\n    vowels = 'aeiou'\n    count = 0\n    for char in text:\n        if char.lower() in vowels:\n            count += 1\n    return str(count)",
      "refactored_code": "def count_vowels(text):\n    vowels = 'aeiou'\n    count = 0\n    for char in text:\n        if char.lower() in vowels:\n            count += 1\n    return count",
      "original_test_result": "FAIL: Expected int, got str",
      "refactored_test_result": "TRUE",
      "comparison": "DIFFERENT",
      "primary_method": "count_vowels"
    },
    {
      "task_id": "task_013",
      "text": "Get the nth element of a list with bounds checking",
      "original code": "def get_nth(lst, n):\n    return lst[n]",
      "refactored_code": "def get_nth(lst, n):\n    if n < 0 or n >= len(lst):\n        return None\n    return lst[n]",
      "original_test_result": "FAIL: IndexError: list index out of range",
      "refactored_test_result": "TRUE",
      "comparison": "DIFFERENT",
      "primary_method": "get_nth"
    },
    {
      "task_id": "task_014",
      "text": "Create a function that joins strings with a separator",
      "original code": "def join_strings(strings, sep):\n    result = ''\n    for i, s in enumerate(strings):\n        result += s\n        if i < len(strings) - 1\n            result += sep\n    return result",
      "refactored_code": "def join_strings(strings, sep):\n    result = ''\n    for i, s in enumerate(strings):\n        result += s\n        if i < len(strings) - 1:\n            result += sep\n    return result",
      "original_test_result": "FAIL: SyntaxError: invalid syntax",
      "refactored_test_result": "TRUE",
      "comparison": "DIFFERENT",
      "primary_method": "join_strings"
    },
    {
      "task_id": "task_015",
      "text": "Calculate the factorial of a number",
      "original code": "def factorial(n):\n    if n <= 1:\n        return 1\n    return n * factorial()",
      "refactored_code": "def factorial(n):\n    if n <= 1:\n        return 1\n    return n * factorial(n - 1)",
      "original_test_result": "FAIL: TypeError: factorial() missing 1 required positional argument",
      "refactored_test_result": "TRUE",
      "comparison": "DIFFERENT",
      "primary_method": "factorial"
    },
    {
      "task_id": "task_016",
      "text": "Split a name into first and last parts",
      "original code": "def split_name(full_name):\n    first, last = full_name.split()\n    return first, last",
      "refactored_code": "def split_name(full_name):\n    parts = full_name.split()\n    first, last = parts[0], parts[-1]\n    return first, last",
      "original_test_result": "FAIL: ValueError: not enough values to unpack",
      "refactored_test_result": "TRUE",
      "comparison": "DIFFERENT",
      "primary_method": "split_name"
    },
    {
      "task_id": "task_017",
      "text": "Calculate compound interest",
      "original code": "def compound_interest(principal, rate, time):\n    return principal * rate * time",
      "refactored_code": "def compound_interest(principal, rate, time):\n    return principal * (1 + rate) ** time - principal",
      "original_test_result": "FAIL: Incorrect formula",
      "refactored_test_result": "TRUE",
      "comparison": "DIFFERENT",
      "primary_method": "compound_interest"
    },
    {
      "task_id": "task_018",
      "text": "Get elements from index 1 to n-1 (exclusive)",
      "original code": "def middle_elements(lst, n):\n    return lst[1:n]",
      "refactored_code": "def middle_elements(lst, n):\n    return lst[1:n-1]",
      "original_test_result": "FAIL: Index range off by one",
      "refactored_test_result": "TRUE",
      "comparison": "DIFFERENT",
      "primary_method": "middle_elements"
    },
    {
      "task_id": "task_019",
      "text": "Return a dictionary of character frequencies",
      "original code": "def char_frequency(text):\n    freq = {}\n    for char in text:\n        if char in freq:\n            freq[char] += 1\n        else:\n            freq[char] = 1\n    return list(freq.items())",
      "refactored_code": "def char_frequency(text):\n    freq = {}\n    for char in text:\n        if char in freq:\n            freq[char] += 1\n        else:\n            freq[char] = 1\n    return freq",
      "original_test_result": "FAIL: Expected dict, got list",
      "refactored_test_result": "TRUE",
      "comparison": "DIFFERENT",
      "primary_method": "char_frequency"
    },
    {
      "task_id": "task_020",
      "text": "Find minimum value in a list with empty list handling",
      "original code": "def find_min(lst):\n    return min(lst)",
      "refactored_code": "def find_min(lst):\n    if not lst:\n        return None\n    return min(lst)",
      "original_test_result": "FAIL: ValueError: min() arg is an empty sequence",
      "refactored_test_result": "TRUE",
      "comparison": "DIFFERENT",
      "primary_method": "find_min"
    },
    {
      "task_id": "task_021",
      "text": "Format a number with specific decimal places",
      "original code": "def format_number(num, places):\n    return f'{num:.{places}f'",
      "refactored_code": "def format_number(num, places):\n    return f'{num:.{places}f}'",
      "original_test_result": "FAIL: SyntaxError: EOL while scanning string literal",
      "refactored_test_result": "TRUE",
      "comparison": "DIFFERENT",
      "primary_method": "format_number"
    },
    {
      "task_id": "task_022",
      "text": "Calculate the average of a list of numbers",
      "original code": "def average(numbers):\n    return sum(numbers) / len(numbers)",
      "refactored_code": "def average(numbers):\n    if not numbers:\n        return 0\n    return sum(numbers) / len(numbers)",
      "original_test_result": "FAIL: TypeError: average() missing 1 required positional argument",
      "refactored_test_result": "TRUE",
      "comparison": "DIFFERENT",
      "primary_method": "average"
    },
    {
      "task_id": "task_023",
      "text": "Extract coordinates from a point tuple",
      "original code": "def get_coordinates(point):\n    x, y, z = point\n    return x, y",
      "refactored_code": "def get_coordinates(point):\n    x, y = point[:2]\n    return x, y",
      "original_test_result": "FAIL: ValueError: not enough values to unpack",
      "refactored_test_result": "TRUE",
      "comparison": "DIFFERENT",
      "primary_method": "get_coordinates"
    },
    {
      "task_id": "task_024",
      "text": "Calculate the hypotenuse of a right triangle",
      "original code": "def hypotenuse(a, b):\n    return a + b",
      "refactored_code": "import math\n\ndef hypotenuse(a, b):\n    return math.sqrt(a*a + b*b)",
      "original_test_result": "FAIL: Incorrect formula",
      "refactored_test_result": "TRUE",
      "comparison": "DIFFERENT",
      "primary_method": "hypotenuse"
    },
    {
      "task_id": "task_025",
      "text": "Get the second-to-last element of a list",
      "original code": "def second_last(lst):\n    return lst[-1]",
      "refactored_code": "def second_last(lst):\n    return lst[-2]",
      "original_test_result": "FAIL: Wrong element returned",
      "refactored_test_result": "TRUE",
      "comparison": "DIFFERENT",
      "primary_method": "second_last"
    },
    {
      "task_id": "task_026",
      "text": "Convert a list of numbers to strings",
      "original code": "def numbers_to_strings(numbers):\n    result = []\n    for num in numbers:\n        result.append(num)\n    return result",
      "refactored_code": "def numbers_to_strings(numbers):\n    result = []\n    for num in numbers:\n        result.append(str(num))\n    return result",
      "original_test_result": "FAIL: Expected list of strings, got list of numbers",
      "refactored_test_result": "TRUE",
      "comparison": "DIFFERENT",
      "primary_method": "numbers_to_strings"
    },
    {
      "task_id": "task_027",
      "text": "Square root with negative number handling",
      "original code": "import math\n\ndef safe_sqrt(x):\n    return math.sqrt(x)",
      "refactored_code": "import math\n\ndef safe_sqrt(x):\n    if x < 0:\n        return None\n    return math.sqrt(x)",
      "original_test_result": "FAIL: ValueError: math domain error",
      "refactored_test_result": "TRUE",
      "comparison": "DIFFERENT",
      "primary_method": "safe_sqrt"
    },
    {
      "task_id": "task_028",
      "text": "Create a function that prints and returns a value",
      "original code": "def print_and_return(value):\n    print(value)\n    return value\n    print('Done')",
      "refactored_code": "def print_and_return(value):\n    print(value)\n    print('Done')\n    return value",
      "original_test_result": "FAIL: SyntaxError: 'return' with value in generator",
      "refactored_test_result": "TRUE",
      "comparison": "DIFFERENT",
      "primary_method": "print_and_return"
    },
    {
      "task_id": "task_029",
      "text": "Get the product of all elements in a list",
      "original code": "def product(numbers):\n    result = 0\n    for num in numbers:\n        result *= num\n    return result",
      "refactored_code": "def product(numbers):\n    result = 1\n    for num in numbers:\n        result *= num\n    return result",
      "original_test_result": "FAIL: Expected product, got 0",
      "refactored_test_result": "TRUE",
      "comparison": "DIFFERENT",
      "primary_method": "product"
    },
    {
      "task_id": "task_030",
      "text": "Concatenate two lists with proper unpacking",
      "original code": "def concat_lists(list1, list2):\n    return list1 + list2[0]",
      "refactored_code": "def concat_lists(list1, list2):\n    return list1 + list2",
      "original_test_result": "FAIL: TypeError: can only concatenate list to list",
      "refactored_test_result": "TRUE",
      "comparison": "DIFFERENT",
      "primary_method": "concat_lists"
    },
    {
      "task_id": "task_031",
      "text": "Calculate the volume of a sphere",
      "original code": "import math\n\ndef sphere_volume(radius):\n    return math.pi * radius ** 3",
      "refactored_code": "import math\n\ndef sphere_volume(radius):\n    return (4/3) * math.pi * radius ** 3",
      "original_test_result": "FAIL: Incorrect formula",
      "refactored_test_result": "TRUE",
      "comparison": "DIFFERENT",
      "primary_method": "sphere_volume"
    },
    {
      "task_id": "task_032",
      "text": "Get elements from start to middle of a list",
      "original code": "def first_half(lst):\n    mid = len(lst) // 2\n    return lst[:mid + 1]",
      "refactored_code": "def first_half(lst):\n    mid = len(lst) // 2\n    return lst[:mid]",
      "original_test_result": "FAIL: Index range includes one extra element",
      "refactored_test_result": "TRUE",
      "comparison": "DIFFERENT",
      "primary_method": "first_half"
    },
    {
      "task_id": "task_033",
      "text": "Return True if all elements in a list are positive",
      "original code": "def all_positive(numbers):\n    for num in numbers:\n        if num <= 0:\n            return False\n    return 'True'",
      "refactored_code": "def all_positive(numbers):\n    for num in numbers:\n        if num <= 0:\n            return False\n    return True",
      "original_test_result": "FAIL: Expected bool, got str",
      "refactored_test_result": "TRUE",
      "comparison": "DIFFERENT",
      "primary_method": "all_positive"
    },
    {
      "task_id": "task_034",
      "text": "Pop an element from a list with bounds checking",
      "original code": "def safe_pop(lst, index):\n    return lst.pop(index)",
      "refactored_code": "def safe_pop(lst, index):\n    if index < 0 or index >= len(lst):\n        return None\n    return lst.pop(index)",
      "original_test_result": "FAIL: IndexError: pop index out of range",
      "refactored_test_result": "TRUE",
      "comparison": "DIFFERENT",
      "primary_method": "safe_pop"
    },
    {
      "task_id": "task_035",
      "text": "Define a function with proper indentation",
      "original code": "def calculate_tax(income, rate):\nreturn income * rate",
      "refactored_code": "def calculate_tax(income, rate):\n    return income * rate",
      "original_test_result": "FAIL: IndentationError: expected an indented block",
      "refactored_test_result": "TRUE",
      "comparison": "DIFFERENT",
      "primary_method": "calculate_tax"
    }
  ]
}